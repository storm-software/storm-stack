/* eslint-disable */
// biome-ignore lint: disable
// prettier-ignore

// Generated by Storm Stack
// Note: Do not edit this file manually - it will be overwritten automatically

import type {
HandlerFunction,
StormContext
} from "@storm-stack/types/node";
import type { StormBaseVariables } from "@storm-stack/types/vars";
import { STORM_ASYNC_CONTEXT } from "./context";
import { build, name, paths, runtime, version } from "./env";
import { createStormError, isError, StormError } from "./error";
import { StormEvent } from "./event";
import { StormPayload } from "./payload";
import { StormResult } from "./result";
import { storage } from "./storage";

/**
 * Wrap an application entry point with the necessary context and error handling.
 *
 * @param handler - The handler function for the application.
 * @returns A function that takes an payload and returns a result or a promise of a result.
 */
export function withContext<TInput = any, TOutput = any>(
  handler: HandlerFunction<TInput, TOutput>
) {
  const disposables = new Set<Disposable>();
  const asyncDisposables = new Set<AsyncDisposable>();

  async function handleExit(): Promise<void> {
    await storage.dispose();

    for (const disposable of disposables) {
      disposable[Symbol.dispose]();
    }
    disposables.clear();

    const promises = [] as PromiseLike<void>[];
    for (const disposable of asyncDisposables) {
      promises.push(disposable[Symbol.asyncDispose]());
      asyncDisposables.delete(disposable);
    }
    await Promise.all(promises);
  }

  const log = new StormLog();
  for (const sink of log.sinks()) {
    if (Symbol.asyncDispose in sink) {
      asyncDisposables.add(sink as AsyncDisposable);
    }
    if (Symbol.dispose in sink) {
      disposables.add(sink as Disposable);
    }
  }

  if ("process" in globalThis && !("Deno" in globalThis)) {
    // eslint-disable-next-line ts/no-misused-promises
    process.on("exit", handleExit);
  }

  return async function wrapper(
    input: TInput
  ): Promise<StormResult<TOutput | StormError>> {
    const payload = new StormPayload<TInput>(input);

    const context = {
      name,
      version,
      payload,
      meta: {},
      build,
      runtime,
      paths,
      log: log.with({ name, version, payloadId: payload.id }),
      storage,
      vars: {} as StormBaseVariables,
      emit: (_event: StormEvent) => {},
      __internal: {
        events: [] as StormEvent[]
      }
    } as StormContext<StormBaseVariables>;

    function emit(event: StormEvent) {
      context.log.debug(
        `The ${event.label} event was emitted by the application.`,
        {
          event
        }
      );

      context.__internal.events.push(event);
    }
    context.emit = emit;

    context.log.debug("Starting the application handler process.", {
      payload
    });

    const result = await STORM_ASYNC_CONTEXT.callAsync(context, async () => {
      try {
        const ret = await Promise.resolve(handler(payload));
        if (isError(ret)) {
          context.log.error(ret);
          return StormResult.create(ret);
        }

        return StormResult.create(ret);
      } catch (err) {
        context.log.fatal(createStormError(err));
        return StormResult.create(err);
      }
    });

    context.log.debug("The application handler process has completed.", {
      result
    });

    return result;
  };
}
