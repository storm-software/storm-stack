/* eslint-disable */
// biome-ignore lint: disable
// prettier-ignore

// Generated by Storm Stack
// Note: Do not edit this file manually - it will be overwritten automatically

import { spinner } from "@clack/prompts";
import type { HandlerFunction, StormContext } from "@storm-stack/types/node";
import type { StormBaseVariables } from "@storm-stack/types/vars";
import os from "node:os";
import { join } from "node:path";
import { link } from "./cli";
import { STORM_ASYNC_CONTEXT } from "./context";
import { appName, appVersion, build, paths, runtime } from "./env";
import { createStormError, isError, StormError } from "./error";
import { StormEvent } from "./event";
import { StormPayload } from "./payload";
import { StormResult } from "./result";
import { storage } from "./storage";

/**
 * Wrap an application entry point with the necessary context and error handling.
 *
 * @param handler - The handler function for the application.
 * @returns A function that takes an payload and returns a result or a promise of a result.
 */
export function withContext<TInput = any, TOutput = any>(
  handler: HandlerFunction<TInput, TOutput>
) {
  const disposables = new Set<Disposable>();
  const asyncDisposables = new Set<AsyncDisposable>();

  let isExitComplete = false;
  async function handleExit(): Promise<void> {
    if (isExitComplete) {
      return;
    }

    await storage.dispose();

    for (const disposable of disposables) {
      disposable[Symbol.dispose]();
    }
    disposables.clear();

    const promises = [] as PromiseLike<void>[];
    for (const disposable of asyncDisposables) {
      promises.push(disposable[Symbol.asyncDispose]());
      asyncDisposables.delete(disposable);
    }
    await Promise.all(promises);

    isExitComplete = true;
  }

  const log = new StormLog();
  for (const sink of log.sinks()) {
    if (Symbol.asyncDispose in sink) {
      asyncDisposables.add(sink as AsyncDisposable);
    }
    if (Symbol.dispose in sink) {
      disposables.add(sink as Disposable);
    }
  }

  if ("process" in globalThis && !("Deno" in globalThis)) {
    // eslint-disable-next-line ts/no-misused-promises
    process.on("exit", handleExit);
  }

  return async function wrapper(input: TInput) {
    const payload = new StormPayload<TInput>(input);

    const context = {
      name: appName,
      version: appVersion,
      payload,
      meta: {},
      build,
      runtime,
      paths,
      log: log.with({
        name: appName,
        version: appVersion,
        payloadId: payload.id
      }),
      storage,
      vars: {} as StormBaseVariables,
      emit: (_event: StormEvent) => {},
      __internal: {
        events: [] as StormEvent[]
      }
    } as StormContext<StormBaseVariables>;

    function emit(event: StormEvent) {
      context.log.debug(
        `The ${event.label} event was emitted by the application.`,
        {
          event
        }
      );

      context.__internal.events.push(event);
    }
    context.emit = emit;

    async function handleShutdown(reason?: StormError) {
      try {
        if (isExitComplete) {
          return;
        }

        const s = spinner();
        s.start(
          "Terminating the application. Please wait to ensure no data is lost..."
        );

        if (reason) {
          context.log.fatal(reason, {
            name: context.name,
            version: context.build.version,
            build: context.build.buildId,
            release: context.build.releaseId,
            tag: context.build.releaseTag,
            mode: context.build.mode,
            os: JSON.stringify({
              type: os.type(),
              release: os.release(),
              platform: os.platform()
            })
          });

          await context.storage.setItem(
            `crash-reports:examples-cli-app-${payload.id}.log`,
            `Examples CLI App - Crash Report

--------------------------------------

  ${reason.toDisplay()}

Application Name: ${context.name}
Application Version: ${context.version}
Timestamp: ${new Date().toISOString()}
Payload ID: ${payload.id}
Build: ${context.build.buildId}
Release: ${context.build.releaseId}
Tag: ${context.build.releaseTag}
Mode: ${context.build.mode}
Operating System: ${os.type()} ${os.release()} ${os.platform()}

--------------------------------------

This crash report was generated by the Examples CLI App application. It contains information about the application and the environment it was running in at the time of the crash. The information in this report is used to help us improve the Examples CLI App application and to provide support for any issues you may encounter. Please reach out to the Storm Software - Support team via our website's support page at: https://stormsoftware.com/support.
          `
          );
        }

        await handleExit();

        s.stop("Completed terminating the application");
        console.log("");

        if (reason) {
          console.log(
            colors.dim(
              `A crash report was generated ${link(`file://${join(paths.log, `examples-cli-app-${payload.id}.log`)}`, "locally on your file system")}. Please include these details when reporting any issues with this software. You can reach out to the Storm Software - Support team via ${link("https://stormsoftware.com/support", "our website's support page")}. `
            )
          );
          console.log("");
        }

        process.exit(reason ? 1 : 0);
      } catch (err) {
        context.log.error("Shutdown process failed to complete", {
          reason,
          error: err
        });

        console.log("");
        console.error(
          ` ${colors.red("✘")} ${colors.redBright("The shutdown process failed to complete. Please check the application logs for more details.")}`
        );
        console.log("");

        process.exit(1);
      }
    }

    for (const type of ["unhandledRejection", "uncaughtException"]) {
      process.on(type, err => {
        console.log("");
        console.error(
          ` ${colors.red("✘")} ${colors.redBright("A fatal error caused the application to crash ")}`
        );
        console.log("");

        void handleShutdown(createStormError(err));
      });
    }

    for (const type of ["SIGTERM", "SIGINT", "SIGUSR2"]) {
      process.once(type, () => {
        console.log("");
        console.log(
          colors.dim(" > The application was terminated by the user ")
        );
        console.log("");

        void handleShutdown();
      });
    }

    context.log.debug("Starting the application handler process.", {
      payload
    });

    const result = await STORM_ASYNC_CONTEXT.callAsync(context, async () => {
      try {
        const ret = await Promise.resolve(handler(payload));
        if (isError(ret)) {
          context.log.error(ret);
          return StormResult.create(ret);
        }

        return StormResult.create(ret);
      } catch (err) {
        await handleShutdown(createStormError(err));
      }
    });

    context.log.debug("The application handler process has completed.", {
      result
    });

    await handleShutdown();
  };
}
