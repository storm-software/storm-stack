/* eslint-disable */
// biome-ignore lint: disable
// prettier-ignore

/// <reference types="../../../../dist/packages/types" />

// Generated by Storm Stack
// Note: Do not edit this file manually - it will be overwritten automatically

declare module "storm:init" {
  export { };
}

declare module "storm:storage" {
  const storage: (typeof import("../runtime/storage"))["storage"];

  export { storage };
}

declare module "storm:error" {
  const _StormError: (typeof import("../runtime/error"))["StormError"];

  class StormError extends _StormError {
    /**
     * The StormError constructor
     *
     * @param options - The options for the error
     * @param type - The type of error
     */
    public constructor(
      optionsOrMessage: StormErrorOptions | string,
      type: ErrorType = "general"
    ) {
      super(optionsOrMessage, type);
    }
  }

  const createStormError: (typeof import("../runtime/error"))["createStormError"];
  const isError: (typeof import("../runtime/error"))["isError"];
  const isStormError: (typeof import("../runtime/error"))["isStormError"];

  export { StormError, createStormError, isError, isStormError };
}

declare module "storm:payload" {
  const _StormPayload: (typeof import("../runtime/payload"))["StormPayload"];

  class StormPayload<TData = any> extends _StormPayload<TData> {
    /**
     * Create a new payload object.
     *
     * @param data - The payload data.
     */
    public constructor(data: TData) {
      super(data);
    }
  }

  export { StormPayload };
}

declare module "storm:result" {
  const _StormResult: (typeof import("../runtime/result"))["StormResult"];

  class StormResult<
    TData extends any | StormError = any | StormError
  > extends _StormResult<TData> {
    /**
     * Create a new result.
     *
     * @param payloadId - The payload identifier.
     * @param meta - The current context's metadata.
     * @param data - The result data
     */
    public constructor(
      payloadId: string,
      meta: Record<string, any>,
      data: TData
    ) {
      super(payloadId, meta, data);
    }
  }

  export { StormResult };
}

declare module "storm:log" {
  /**
   * The StormLog class that's used for writing logs during Storm Stack applications.
   */
  class StormLog implements IStormLog {
    public readonly filters: LogFilter[];

    public lowestLogLevel: LogLevel | null;

    public constructor() {}

    public with(properties: Record<string, unknown>): IStormLog;

    public filter(record: LogRecord): boolean;

    public *sinks(level?: LogLevel): Iterable<LogSink>;

    public emit(record: LogRecord, bypassSinks?: Set<LogSink>): void;

    public log(
      level: LogLevel,
      rawMessage: string,
      properties: Record<string, unknown> | (() => Record<string, unknown>),
      bypassSinks?: Set<LogSink>
    ): void;

    public logLazily(
      level: LogLevel,
      callback: LogCallback,
      properties: Record<string, unknown> = {}
    ): void;

    public logTemplate(
      level: LogLevel,
      messageTemplate: TemplateStringsArray,
      values: unknown[],
      properties: Record<string, unknown> = {}
    ): void;

    public debug(
      message: TemplateStringsArray | string | LogCallback,
      ...values: unknown[]
    ): void;

    public info(
      message: TemplateStringsArray | string | LogCallback,
      ...values: unknown[]
    ): void;

    public warn(
      message: TemplateStringsArray | string | LogCallback,
      ...values: unknown[]
    ): void;

    public error(
      message: TemplateStringsArray | string | LogCallback | Error,
      ...values: unknown[]
    ): void;

    public fatal(
      message: TemplateStringsArray | string | LogCallback | Error,
      ...values: unknown[]
    ): void;
  }

  export { StormLog };
}

declare module "storm:id" {
  const uniqueId: (typeof import("../runtime/id"))["uniqueId"];
  const getRandom: (typeof import("../runtime/id"))["getRandom"];

  export { getRandom, uniqueId };
}
