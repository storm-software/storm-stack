## API Report File for "@storm-stack/types"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
const $NestedValue: unique symbol;
export { $NestedValue }
export { $NestedValue as $NestedValue_alias_1 }
export { $NestedValue as $NestedValue_alias_2 }

// @public (undocumented)
interface Abstract<T> {
    // (undocumented)
    prototype: T;
}
export { Abstract }
export { Abstract as Abstract_alias_1 }
export { Abstract as Abstract_alias_2 }

// @public
interface AbstractClass<T, Arguments extends unknown[] = any[]> extends AbstractConstructor<T, Arguments> {
    // (undocumented)
    prototype: Pick<T, keyof T>;
}
export { AbstractClass }
export { AbstractClass as AbstractClass_alias_1 }
export { AbstractClass as AbstractClass_alias_2 }

// @public
type AbstractConstructor<T, Arguments extends unknown[] = any[]> = abstract new (...arguments_: Arguments) => T;
export { AbstractConstructor }
export { AbstractConstructor as AbstractConstructor_alias_1 }
export { AbstractConstructor as AbstractConstructor_alias_2 }

// @public (undocumented)
type And<A extends boolean, B extends boolean> = [
A,
B
][number] extends true ? true : true extends [IsEqual<A, false>, IsEqual<B, false>][number] ? false : never;
export { And }
export { And as And_alias_1 }
export { And as And_alias_2 }

// @public (undocumented)
type Any = boolean | number | bigint | string | null | undefined | void | symbol | object | PlainObject | AnyArray | AnyMap | AnyWeakMap;
export { Any }
export { Any as Any_alias_1 }
export { Any as Any_alias_2 }

// @public (undocumented)
type AnyArray = any[];
export { AnyArray }
export { AnyArray as AnyArray_alias_1 }
export { AnyArray as AnyArray_alias_2 }

// @public (undocumented)
type AnyBoolean = boolean | boolean;
export { AnyBoolean }
export { AnyBoolean as AnyBoolean_alias_1 }
export { AnyBoolean as AnyBoolean_alias_2 }

// @public (undocumented)
type AnyCase<T extends IndexType> = string extends T ? string : T extends `${infer F1}${infer F2}${infer R}` ? `${Uppercase<F1> | Lowercase<F1>}${Uppercase<F2> | Lowercase<F2>}${AnyCase<R>}` : T extends `${infer F}${infer R}` ? `${Uppercase<F> | Lowercase<F>}${AnyCase<R>}` : typeof EMPTY_STRING;
export { AnyCase }
export { AnyCase as AnyCase_alias_1 }
export { AnyCase as AnyCase_alias_2 }

// @public (undocumented)
type AnyFunction = Function | ((...args: any) => any);
export { AnyFunction }
export { AnyFunction as AnyFunction_alias_1 }
export { AnyFunction as AnyFunction_alias_2 }

// @public (undocumented)
type AnyMap = Map<any, any>;
export { AnyMap }
export { AnyMap as AnyMap_alias_1 }
export { AnyMap as AnyMap_alias_2 }

// @public (undocumented)
type AnyNumber = number | number;
export { AnyNumber }
export { AnyNumber as AnyNumber_alias_1 }
export { AnyNumber as AnyNumber_alias_2 }

// @public (undocumented)
type AnyString = string | string;
export { AnyString }
export { AnyString as AnyString_alias_1 }
export { AnyString as AnyString_alias_2 }

// @public (undocumented)
type AnyWeakMap = WeakMap<WeakKey, any>;
export { AnyWeakMap }
export { AnyWeakMap as AnyWeakMap_alias_1 }
export { AnyWeakMap as AnyWeakMap_alias_2 }

// @public
type ArrayElement<T> = T extends readonly unknown[] ? T[0] : never;
export { ArrayElement }
export { ArrayElement as ArrayElement_alias_1 }
export { ArrayElement as ArrayElement_alias_2 }

// @public
type ArrayIndices<Element extends readonly unknown[]> = Exclude<Partial<Element>["length"], Element["length"]>;
export { ArrayIndices }
export { ArrayIndices as ArrayIndices_alias_1 }
export { ArrayIndices as ArrayIndices_alias_2 }

// @public
type ArrayLength<T extends readonly unknown[]> = T extends {
    readonly length: infer L;
} ? L : never;
export { ArrayLength }
export { ArrayLength as ArrayLength_alias_1 }
export { ArrayLength as ArrayLength_alias_2 }

// @public
type ArrayMax<A extends number[], Result extends number = NegativeInfinity> = number extends A[number] ? never : A extends [infer F extends number, ...infer R extends number[]] ? GreaterThan<F, Result> extends true ? ArrayMax<R, F> : ArrayMax<R, Result> : Result;
export { ArrayMax }
export { ArrayMax as ArrayMax_alias_1 }
export { ArrayMax as ArrayMax_alias_2 }

// @public
type ArrayMin<A extends number[], Result extends number = PositiveInfinity> = number extends A[number] ? never : A extends [infer F extends number, ...infer R extends number[]] ? LessThan<F, Result> extends true ? ArrayMin<R, F> : ArrayMin<R, Result> : Result;
export { ArrayMin }
export { ArrayMin as ArrayMin_alias_1 }
export { ArrayMin as ArrayMin_alias_2 }

// @public
type ArrayValues<T extends readonly unknown[]> = T[number];
export { ArrayValues }
export { ArrayValues as ArrayValues_alias_1 }
export { ArrayValues as ArrayValues_alias_2 }

// @public (undocumented)
type AsyncFunction = (...arguments_: any[]) => Promise<unknown>;
export { AsyncFunction }
export { AsyncFunction as AsyncFunction_alias_1 }
export { AsyncFunction as AsyncFunction_alias_2 }

// @public
type Asyncify<Function_ extends (...arguments_: any[]) => any> = SetReturnType<Function_, Promise<Awaited<ReturnType<Function_>>>>;
export { Asyncify }
export { Asyncify as Asyncify_alias_1 }
export { Asyncify as Asyncify_alias_2 }

// @public
type AsyncReturnType<Target extends AsyncFunction> = Awaited<ReturnType<Target>>;
export { AsyncReturnType }
export { AsyncReturnType as AsyncReturnType_alias_1 }
export { AsyncReturnType as AsyncReturnType_alias_2 }

// @public
type AtomicObject = Function | Promise<any> | Date | RegExp;
export { AtomicObject }
export { AtomicObject as AtomicObject_alias_1 }
export { AtomicObject as AtomicObject_alias_2 }

// @public (undocumented)
type BrowserNativeObject = Date | File;
export { BrowserNativeObject }
export { BrowserNativeObject as BrowserNativeObject_alias_1 }
export { BrowserNativeObject as BrowserNativeObject_alias_2 }

// @public
type BuildObject<Key extends PropertyKey, Value, CopiedFrom extends object = {}> = Key extends keyof CopiedFrom ? Pick<{
    [_ in keyof CopiedFrom]: Value;
}, Key> : Key extends `${infer NumberKey extends number}` ? NumberKey extends keyof CopiedFrom ? Pick<{
    [_ in keyof CopiedFrom]: Value;
}, NumberKey> : {
    [_ in Key]: Value;
} : {
    [_ in Key]: Value;
};
export { BuildObject }
export { BuildObject as BuildObject_alias_1 }
export { BuildObject as BuildObject_alias_2 }

// @public
type BuildTuple<L extends number, Fill = unknown, T extends readonly unknown[] = []> = T["length"] extends L ? T : BuildTuple<L, Fill, [...T, Fill]>;
export { BuildTuple }
export { BuildTuple as BuildTuple_alias_1 }
export { BuildTuple as BuildTuple_alias_2 }

// @public
type BuiltIns = Primitive | void | Date | RegExp;
export { BuiltIns }
export { BuiltIns as BuiltIns_alias_1 }
export { BuiltIns as BuiltIns_alias_2 }

// @public
interface Class<T, Arguments extends unknown[] = any[]> {
    // (undocumented)
    new (...arguments_: Arguments): T;
    // (undocumented)
    prototype: Pick<T, keyof T>;
}
export { Class }
export { Class as Class_alias_1 }
export { Class as Class_alias_2 }

// @public (undocumented)
interface ClassTypeCheckable<T> extends ITyped {
    isTypeOf: (value: unknown) => value is T;
}
export { ClassTypeCheckable }
export { ClassTypeCheckable as ClassTypeCheckable_alias_1 }
export { ClassTypeCheckable as ClassTypeCheckable_alias_2 }

// @public (undocumented)
interface Clonable<T> {
    // (undocumented)
    clone(): T;
}
export { Clonable }
export { Clonable as Clonable_alias_1 }
export { Clonable as Clonable_alias_2 }

// @public (undocumented)
type Collection = IArguments | unknown[] | Map<unknown, unknown> | Record<string | number | symbol, unknown> | Set<unknown>;
export { Collection }
export { Collection as Collection_alias_1 }
export { Collection as Collection_alias_2 }

// @public (undocumented)
interface CompilerOptions {
    allowArbitraryExtensions?: boolean;
    allowImportingTsExtensions?: boolean;
    allowJs?: boolean;
    allowSyntheticDefaultImports?: boolean;
    allowUmdGlobalAccess?: boolean;
    allowUnreachableCode?: boolean;
    allowUnusedLabels?: boolean;
    alwaysStrict?: boolean;
    assumeChangesOnlyAffectDirectDependencies?: boolean;
    baseUrl?: string;
    // @deprecated
    charset?: string;
    checkJs?: boolean;
    composite?: boolean;
    customConditions?: string[];
    declaration?: boolean;
    declarationDir?: string;
    declarationMap?: boolean;
    diagnostics?: boolean;
    disableReferencedProjectLoad?: boolean;
    disableSizeLimit?: boolean;
    disableSolutionSearching?: boolean;
    disableSourceOfProjectReferenceRedirect?: boolean;
    downlevelIteration?: boolean;
    emitBOM?: boolean;
    emitDeclarationOnly?: boolean;
    emitDecoratorMetadata?: boolean;
    esModuleInterop?: boolean;
    exactOptionalPropertyTypes?: boolean;
    experimentalDecorators?: boolean;
    explainFiles?: boolean;
    extendedDiagnostics?: boolean;
    // @deprecated
    fallbackPolling?: FallbackPolling;
    forceConsistentCasingInFileNames?: boolean;
    generateCpuProfile?: string;
    ignoreDeprecations?: IgnoreDeprecations;
    importHelpers?: boolean;
    // @deprecated
    importsNotUsedAsValues?: ImportsNotUsedAsValues;
    incremental?: boolean;
    inlineSourceMap?: boolean;
    inlineSources?: boolean;
    isolatedModules?: boolean;
    jsx?: JSX;
    jsxFactory?: string;
    jsxFragmentFactory?: string;
    jsxImportSource?: string;
    // @deprecated
    keyofStringsOnly?: boolean;
    lib?: Lib[];
    listEmittedFiles?: boolean;
    listFiles?: boolean;
    listFilesOnly?: boolean;
    mapRoot?: string;
    maxNodeModuleJsDepth?: number;
    module?: Module;
    moduleDetection?: ModuleDetection;
    moduleResolution?: ModuleResolution;
    moduleSuffixes?: string[];
    newLine?: NewLine;
    noEmit?: boolean;
    noEmitHelpers?: boolean;
    noEmitOnError?: boolean;
    noErrorTruncation?: boolean;
    noFallthroughCasesInSwitch?: boolean;
    noImplicitAny?: boolean;
    noImplicitOverride?: boolean;
    noImplicitReturns?: boolean;
    noImplicitThis?: boolean;
    // @deprecated
    noImplicitUseStrict?: boolean;
    noLib?: boolean;
    noPropertyAccessFromIndexSignature?: boolean;
    noResolve?: boolean;
    // @deprecated
    noStrictGenericChecks?: boolean;
    noUncheckedIndexedAccess?: boolean;
    noUnusedLocals?: boolean;
    noUnusedParameters?: boolean;
    outDir?: string;
    outFile?: string;
    paths?: Record<string, string[]>;
    plugins?: Plugin[];
    preserveConstEnums?: boolean;
    preserveSymlinks?: boolean;
    // @deprecated
    preserveValueImports?: boolean;
    preserveWatchOutput?: boolean;
    pretty?: boolean;
    reactNamespace?: string;
    removeComments?: boolean;
    resolveJsonModule?: boolean;
    resolvePackageJsonExports?: boolean;
    resolvePackageJsonImports?: boolean;
    rootDir?: string;
    rootDirs?: string[];
    // @deprecated (undocumented)
    skipDefaultLibCheck?: boolean;
    skipLibCheck?: boolean;
    sourceMap?: boolean;
    sourceRoot?: string;
    strict?: boolean;
    strictBindCallApply?: boolean;
    strictFunctionTypes?: boolean;
    strictNullChecks?: boolean;
    strictPropertyInitialization?: boolean;
    stripInternal?: boolean;
    // @deprecated
    suppressExcessPropertyErrors?: boolean;
    // @deprecated
    suppressImplicitAnyIndexErrors?: boolean;
    target?: Target;
    traceResolution?: boolean;
    tsBuildInfoFile?: string;
    typeRoots?: string[];
    types?: string[];
    useDefineForClassFields?: boolean;
    useUnknownInCatchVariables?: boolean;
    verbatimModuleSyntax?: boolean;
    // @deprecated
    watch?: boolean;
    // @deprecated
    watchDirectory?: WatchDirectory;
    // @deprecated
    watchFile?: WatchFile;
}
export { CompilerOptions }
export { CompilerOptions as CompilerOptions_alias_1 }
export { CompilerOptions as CompilerOptions_alias_2 }

// @public (undocumented)
type ComputeRange<N extends number, Result extends unknown[] = []> = Result["length"] extends N ? Result : ComputeRange<N, [...Result, Result["length"]]>;
export { ComputeRange }
export { ComputeRange as ComputeRange_alias_1 }
export { ComputeRange as ComputeRange_alias_2 }

// @public
type Constructor<T, Arguments extends unknown[] = any[]> = new (...arguments_: Arguments) => T;
export { Constructor }
export { Constructor as Constructor_alias_1 }
export { Constructor as Constructor_alias_2 }

// @public (undocumented)
type DeepKey<T, TDepth extends any[] = []> = TDepth["length"] extends 5 ? never : unknown extends T ? PrefixFromDepth<string, TDepth> : T extends IsTuple<T> & any[] ? PrefixTupleAccessor<T, AllowedIndexes<T>, TDepth> : T extends any[] ? PrefixArrayAccessor<T, [...TDepth, any]> : T extends Date ? never : T extends object ? PrefixObjectAccessor<T, TDepth> : T extends bigint | boolean | number | string ? "" : never;
export { DeepKey }
export { DeepKey as DeepKey_alias_1 }
export { DeepKey as DeepKey_alias_2 }

// @public (undocumented)
type DeepPartial<T> = T extends BrowserNativeObject | NestedValue ? T : {
    [K in keyof T]?: DeepPartial<T[K]>;
};
export { DeepPartial }
export { DeepPartial as DeepPartial_alias_1 }
export { DeepPartial as DeepPartial_alias_2 }

// @public (undocumented)
type DeepValue<TObject extends Record<string, unknown>, TPath extends DeepKey<TObject>> = GetWithPath<TObject, ToPath<TPath>>;
export { DeepValue }
export { DeepValue as DeepValue_alias_1 }
export { DeepValue as DeepValue_alias_2 }

// @public (undocumented)
const EMPTY_OBJECT: {};
export { EMPTY_OBJECT }
export { EMPTY_OBJECT as EMPTY_OBJECT_alias_1 }
export { EMPTY_OBJECT as EMPTY_OBJECT_alias_2 }

// @public (undocumented)
const EMPTY_STRING = "";
export { EMPTY_STRING }
export { EMPTY_STRING as EMPTY_STRING_alias_1 }
export { EMPTY_STRING as EMPTY_STRING_alias_2 }

// @public (undocumented)
type EmptyArray = [];
export { EmptyArray }
export { EmptyArray as EmptyArray_alias_1 }
export { EmptyArray as EmptyArray_alias_2 }

// @public (undocumented)
interface EmptyObject {
    // (undocumented)
    [emptyObjectSymbol]?: never;
}
export { EmptyObject }
export { EmptyObject as EmptyObject_alias_1 }
export { EmptyObject as EmptyObject_alias_2 }

// @public (undocumented)
type ErrorMessageDetails = {
    type: "error";
} & Omit<MessageDetails, "type">;
export { ErrorMessageDetails }
export { ErrorMessageDetails as ErrorMessageDetails_alias_1 }
export { ErrorMessageDetails as ErrorMessageDetails_alias_2 }

// @public
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {
    requireExactProps: false;
}> = {
    [KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options["requireExactProps"] extends true ? Partial<Record<KeysType, never>> : Record<string, never>);
export { Except }
export { Except as Except_alias_1 }
export { Except as Except_alias_2 }

// @public (undocumented)
type FallbackPolling = "fixedPollingInterval" | "priorityPollingInterval" | "dynamicPriorityPolling" | "fixedInterval" | "priorityInterval" | "dynamicPriority" | "fixedChunkSize";
export { FallbackPolling }
export { FallbackPolling as FallbackPolling_alias_1 }
export { FallbackPolling as FallbackPolling_alias_2 }

// @public (undocumented)
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : KeyType extends ExcludeType ? never : KeyType;
export { Filter }
export { Filter as Filter_alias_1 }
export { Filter as Filter_alias_2 }

// @public (undocumented)
const filterEmpty: <T>(values?: (T | null | undefined)[]) => T[];
export { filterEmpty }
export { filterEmpty as filterEmpty_alias_1 }
export { filterEmpty as filterEmpty_alias_2 }

// @public
export type Finite<T extends number> = T extends PositiveInfinity | NegativeInfinity ? never : T;

// @public
type FirstArrayElement<TArray extends UnknownArrayOrTuple> = TArray extends readonly [infer THead, ...unknown[]] ? THead : never;
export { FirstArrayElement }
export { FirstArrayElement as FirstArrayElement_alias_1 }
export { FirstArrayElement as FirstArrayElement_alias_2 }

// @public
export type Float<T> = T extends unknown ? IsFloat<T> extends true ? T : never : never;

// @public
type Get<BaseType, Path extends readonly string[] | string, Options extends GetOptions = {}> = GetWithPath<BaseType, Path extends string ? ToPath<Path> : Path, Options>;
export { Get }
export { Get as Get_alias_1 }
export { Get as Get_alias_2 }

// @public
type GetWithPath<BaseType, Keys extends readonly string[], Options extends GetOptions = {}> = Keys extends readonly [] ? BaseType : Keys extends readonly [infer Head, ...infer Tail] ? GetWithPath<PropertyOf<BaseType, Extract<Head, string>, Options>, Extract<Tail, string[]>, Options> : never;
export { GetWithPath }
export { GetWithPath as GetWithPath_alias_1 }
export { GetWithPath as GetWithPath_alias_2 }

// @public
type GlobalThis = typeof globalThis;
export { GlobalThis }
export { GlobalThis as GlobalThis_alias_1 }
export { GlobalThis as GlobalThis_alias_2 }

// @public (undocumented)
type GreaterThan<A extends number, B extends number> = number extends A | B ? never : [
IsEqual<A, PositiveInfinity>,
IsEqual<A, NegativeInfinity>,
IsEqual<B, PositiveInfinity>,
IsEqual<B, NegativeInfinity>
] extends infer R extends [boolean, boolean, boolean, boolean] ? Or<And<IsEqual<R[0], true>, IsEqual<R[2], false>>, And<IsEqual<R[3], true>, IsEqual<R[1], false>>> extends true ? true : Or<And<IsEqual<R[1], true>, IsEqual<R[3], false>>, And<IsEqual<R[2], true>, IsEqual<R[0], false>>> extends true ? false : true extends R[number] ? false : [IsNegative<A>, IsNegative<B>] extends infer R extends [
boolean,
boolean
] ? [true, false] extends R ? false : [false, true] extends R ? true : [false, false] extends R ? PositiveNumericStringGt<`${A}`, `${B}`> : PositiveNumericStringGt<`${NumberAbsolute<B>}`, `${NumberAbsolute<A>}`> : never : never;
export { GreaterThan }
export { GreaterThan as GreaterThan_alias_1 }
export { GreaterThan as GreaterThan_alias_2 }

// @public (undocumented)
type GreaterThanOrEqual<A extends number, B extends number> = number extends A | B ? never : A extends B ? true : GreaterThan<A, B>;
export { GreaterThanOrEqual }
export { GreaterThanOrEqual as GreaterThanOrEqual_alias_1 }
export { GreaterThanOrEqual as GreaterThanOrEqual_alias_2 }

// @public
type HasMultipleCallSignatures<T extends (...arguments_: any[]) => unknown> = T extends {
    (...arguments_: infer A): unknown;
    (...arguments_: infer B): unknown;
} ? B extends A ? A extends B ? false : true : true : false;
export { HasMultipleCallSignatures }
export { HasMultipleCallSignatures as HasMultipleCallSignatures_alias_1 }
export { HasMultipleCallSignatures as HasMultipleCallSignatures_alias_2 }

// @public (undocumented)
type IgnoreDeprecations = "5.0";
export { IgnoreDeprecations }
export { IgnoreDeprecations as IgnoreDeprecations_alias_1 }
export { IgnoreDeprecations as IgnoreDeprecations_alias_2 }

// @public (undocumented)
interface IIdentity<T = string> {
    // (undocumented)
    id: T;
}
export { IIdentity }
export { IIdentity as IIdentity_alias_1 }
export { IIdentity as IIdentity_alias_2 }

// @public (undocumented)
type ImportsNotUsedAsValues = "remove" | "preserve" | "error";
export { ImportsNotUsedAsValues }
export { ImportsNotUsedAsValues as ImportsNotUsedAsValues_alias_1 }
export { ImportsNotUsedAsValues as ImportsNotUsedAsValues_alias_2 }

// @public (undocumented)
type Index40 = ComputeRange<40>[number];
export { Index40 }
export { Index40 as Index40_alias_1 }
export { Index40 as Index40_alias_2 }

// @public
type Indexable = Record<IndexType, any>;
export { Indexable }
export { Indexable as Indexable_alias_1 }
export { Indexable as Indexable_alias_2 }

// @public
type IndexType = string | number | symbol;
export { IndexType }
export { IndexType as IndexType_alias_1 }
export { IndexType as IndexType_alias_2 }

// @public (undocumented)
type InfoMessageDetails = {
    type: "info";
} & Omit<MessageDetails, "type">;
export { InfoMessageDetails }
export { InfoMessageDetails as InfoMessageDetails_alias_1 }
export { InfoMessageDetails as InfoMessageDetails_alias_2 }

// @public
export type Integer<T> = T extends unknown ? IsInteger<T> extends true ? T : never : never;

// @public (undocumented)
type InternalPaths<_T, Depth extends number = 0, T = Required<_T>> = T extends EmptyObject | readonly [] ? never : {
    [Key in keyof T]: Key extends number | string ? Key | (LessThan<Depth, 15> extends true ? IsNever<Paths_<T[Key], Sum<Depth, 1>>> extends false ? `${Key}.${Paths_<T[Key], Sum<Depth, 1>>}` : never : never) | ToString<Key> : never;
}[(T extends UnknownArray ? number : unknown) & keyof T];
export { InternalPaths }
export { InternalPaths as InternalPaths_alias_1 }
export { InternalPaths as InternalPaths_alias_2 }

// @public (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;
export { IsAny }
export { IsAny as IsAny_alias_1 }
export { IsAny as IsAny_alias_2 }

// @public (undocumented)
type IsBooleanLiteral<T> = LiteralCheck<T, boolean>;
export { IsBooleanLiteral }
export { IsBooleanLiteral as IsBooleanLiteral_alias_1 }
export { IsBooleanLiteral as IsBooleanLiteral_alias_2 }

// @public (undocumented)
type IsEmptyObject<T> = T extends EmptyObject ? true : false;
export { IsEmptyObject }
export { IsEmptyObject as IsEmptyObject_alias_1 }
export { IsEmptyObject as IsEmptyObject_alias_2 }

// @public
type IsEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends <G>() => G extends B ? 1 : 2 ? true : false;
export { IsEqual }
export { IsEqual as IsEqual_alias_1 }
export { IsEqual as IsEqual_alias_2 }

// @public (undocumented)
interface ISequenced {
    sequence: number;
}
export { ISequenced }
export { ISequenced as ISequenced_alias_1 }
export { ISequenced as ISequenced_alias_2 }

// @public (undocumented)
export type IsFloat<T> = T extends number ? `${T}` extends `${infer _Sign extends "" | "-"}${number}.${infer Decimal extends number}` ? Decimal extends Zero ? false : true : false : false;

// @public (undocumented)
type IsFunction<T> = T extends AnyFunction ? true : false;
export { IsFunction }
export { IsFunction as IsFunction_alias_1 }
export { IsFunction as IsFunction_alias_2 }

// @public (undocumented)
export type IsInteger<T> = T extends bigint ? true : T extends number ? number extends T ? false : T extends PositiveInfinity | NegativeInfinity ? false : Not<IsFloat<T>> : false;

// @public (undocumented)
type IsLiteral<T> = IsPrimitive<T> extends true ? IsNotFalse<IsLiteralUnion<T>> : false;
export { IsLiteral }
export { IsLiteral as IsLiteral_alias_1 }
export { IsLiteral as IsLiteral_alias_2 }

// @public
export type IsNegative<T extends Numeric> = T extends Negative<T> ? true : false;

// @public (undocumented)
type IsNever<T> = [T] extends [never] ? true : false;
export { IsNever }
export { IsNever as IsNever_alias_1 }
export { IsNever as IsNever_alias_2 }

// @public
type IsNotFalse<T extends boolean> = [T] extends [false] ? false : true;
export { IsNotFalse }
export { IsNotFalse as IsNotFalse_alias_1 }
export { IsNotFalse as IsNotFalse_alias_2 }

// @public (undocumented)
type IsNull<T> = [T] extends [null] ? true : false;
export { IsNull }
export { IsNull as IsNull_alias_1 }
export { IsNull as IsNull_alias_2 }

// @public (undocumented)
type IsNullable<T> = [null] extends [T] ? true : false;
export { IsNullable }
export { IsNullable as IsNullable_alias_1 }
export { IsNullable as IsNullable_alias_2 }

// @public (undocumented)
type IsNullish<T> = IsNull<T> & IsUndefined<T>;
export { IsNullish }
export { IsNullish as IsNullish_alias_1 }
export { IsNullish as IsNullish_alias_2 }

// @public (undocumented)
type IsNumericLiteral<T> = LiteralChecks<T, Numeric>;
export { IsNumericLiteral }
export { IsNumericLiteral as IsNumericLiteral_alias_1 }
export { IsNumericLiteral as IsNumericLiteral_alias_2 }

// @public
type IsPlainObject<T> = T extends NonRecursiveType | ReadonlyMap<unknown, unknown> | ReadonlySet<unknown> | UnknownArray ? false : T extends object ? true : false;
export { IsPlainObject }
export { IsPlainObject as IsPlainObject_alias_1 }
export { IsPlainObject as IsPlainObject_alias_2 }

// @public (undocumented)
type IsPrimitive<T> = [T] extends [Primitive] ? true : false;
export { IsPrimitive }
export { IsPrimitive as IsPrimitive_alias_1 }
export { IsPrimitive as IsPrimitive_alias_2 }

// @public (undocumented)
type IsStringLiteral<T> = LiteralCheck<T, string>;
export { IsStringLiteral }
export { IsStringLiteral as IsStringLiteral_alias_1 }
export { IsStringLiteral as IsStringLiteral_alias_2 }

// @public (undocumented)
type IsSymbolLiteral<T> = LiteralCheck<T, symbol>;
export { IsSymbolLiteral }
export { IsSymbolLiteral as IsSymbolLiteral_alias_1 }
export { IsSymbolLiteral as IsSymbolLiteral_alias_2 }

// @public (undocumented)
type IsUndefined<T> = T extends undefined ? true : false;
export { IsUndefined }
export { IsUndefined as IsUndefined_alias_1 }
export { IsUndefined as IsUndefined_alias_2 }

// @public (undocumented)
type IsUnknown<T> = unknown extends T ? IsNull<T> extends false ? true : false : false;
export { IsUnknown }
export { IsUnknown as IsUnknown_alias_1 }
export { IsUnknown as IsUnknown_alias_2 }

// @public (undocumented)
interface ITyped {
    __typename: string;
}
export { ITyped }
export { ITyped as ITyped_alias_1 }
export { ITyped as ITyped_alias_2 }

// @public (undocumented)
interface IVersioned {
    // (undocumented)
    version: number;
}
export { IVersioned }
export { IVersioned as IVersioned_alias_1 }
export { IVersioned as IVersioned_alias_2 }

// @public
type JsonArray = JsonValue[] | readonly JsonValue[];
export { JsonArray }
export { JsonArray as JsonArray_alias_1 }
export { JsonArray as JsonArray_alias_2 }

// @public (undocumented)
type JsonObject = {
    [Key in string]: JsonValue;
} & {
    [Key in string]?: JsonValue | undefined;
};
export { JsonObject }
export { JsonObject as JsonObject_alias_1 }
export { JsonObject as JsonObject_alias_2 }

// @public
type JsonPrimitive = string | number | boolean | null;
export { JsonPrimitive }
export { JsonPrimitive as JsonPrimitive_alias_1 }
export { JsonPrimitive as JsonPrimitive_alias_2 }

// @public
type JsonValue = JsonPrimitive | JsonObject | JsonArray;
export { JsonValue }
export { JsonValue as JsonValue_alias_1 }
export { JsonValue as JsonValue_alias_2 }

// @public (undocumented)
type JSX = "preserve" | "react" | "react-jsx" | "react-jsxdev" | "react-native";
export { JSX }
export { JSX as JSX_alias_1 }
export { JSX as JSX_alias_2 }

// @public
type LastArrayElement<Elements extends readonly unknown[], ElementBeforeTailingSpreadElement = never> = Elements extends readonly [] ? ElementBeforeTailingSpreadElement : Elements extends readonly [...infer _U, infer V] ? V : Elements extends readonly [infer U, ...infer V] ? LastArrayElement<V, U> : Elements extends readonly (infer U)[] ? ElementBeforeTailingSpreadElement | U : never;
export { LastArrayElement }
export { LastArrayElement as LastArrayElement_alias_1 }
export { LastArrayElement as LastArrayElement_alias_2 }

// @public (undocumented)
type LessThan<A extends number, B extends number> = number extends A | B ? never : GreaterThanOrEqual<A, B> extends true ? false : true;
export { LessThan }
export { LessThan as LessThan_alias_1 }
export { LessThan as LessThan_alias_2 }

// @public (undocumented)
type Lib = "ES5" | "ES6" | "ES7" | "ES2015" | "ES2015.Collection" | "ES2015.Core" | "ES2015.Generator" | "ES2015.Iterable" | "ES2015.Promise" | "ES2015.Proxy" | "ES2015.Reflect" | "ES2015.Symbol.WellKnown" | "ES2015.Symbol" | "ES2016" | "ES2016.Array.Include" | "ES2017" | "ES2017.Intl" | "ES2017.Object" | "ES2017.SharedMemory" | "ES2017.String" | "ES2017.TypedArrays" | "ES2018" | "ES2018.AsyncGenerator" | "ES2018.AsyncIterable" | "ES2018.Intl" | "ES2018.Promise" | "ES2018.Regexp" | "ES2019" | "ES2019.Array" | "ES2019.Object" | "ES2019.String" | "ES2019.Symbol" | "ES2020" | "ES2020.BigInt" | "ES2020.Promise" | "ES2020.String" | "ES2020.Symbol.WellKnown" | "ES2020.SharedMemory" | "ES2020.Intl" | "ES2021" | "ES2021.Promise" | "ES2021.String" | "ES2021.WeakRef" | "ES2022" | "ES2022.Array" | "ES2022.Error" | "ES2022.Intl" | "ES2022.Object" | "ES2022.SharedMemory" | "ES2022.String" | "ES2022.RegExp" | "ESNext" | "ESNext.Array" | "ESNext.AsyncIterable" | "ESNext.BigInt" | "ESNext.Intl" | "ESNext.Promise" | "ESNext.String" | "ESNext.Symbol" | "ESNext.WeakRef" | "DOM" | "DOM.Iterable" | "ScriptHost" | "WebWorker" | "WebWorker.ImportScripts" | "WebWorker.Iterable" | "es5" | "es6" | "es7" | "es2015" | "es2015.collection" | "es2015.core" | "es2015.generator" | "es2015.iterable" | "es2015.promise" | "es2015.proxy" | "es2015.reflect" | "es2015.symbol.wellknown" | "es2015.symbol" | "es2016" | "es2016.array.include" | "es2017" | "es2017.intl" | "es2017.object" | "es2017.sharedmemory" | "es2017.string" | "es2017.typedarrays" | "es2018" | "es2018.asyncgenerator" | "es2018.asynciterable" | "es2018.intl" | "es2018.promise" | "es2018.regexp" | "es2019" | "es2019.array" | "es2019.object" | "es2019.string" | "es2019.symbol" | "es2020" | "es2020.bigint" | "es2020.promise" | "es2020.string" | "es2020.symbol.wellknown" | "es2020.sharedmemory" | "es2020.intl" | "es2021" | "es2021.promise" | "es2021.string" | "es2021.weakref" | "es2022" | "es2022.array" | "es2022.error" | "es2022.intl" | "es2022.object" | "es2022.sharedmemory" | "es2022.string" | "es2022.regexp" | "esnext" | "esnext.array" | "esnext.asynciterable" | "esnext.bigint" | "esnext.intl" | "esnext.promise" | "esnext.string" | "esnext.symbol" | "esnext.weakref" | "dom" | "dom.iterable" | "scripthost" | "webworker" | "webworker.importscripts" | "webworker.iterable";
export { Lib }
export { Lib as Lib_alias_1 }
export { Lib as Lib_alias_2 }

// @public
type LiteralKeyOf<T> = keyof {
    [K in keyof T as IsLiteral<K> extends true ? K : never]-?: never;
};
export { LiteralKeyOf }
export { LiteralKeyOf as LiteralKeyOf_alias_1 }
export { LiteralKeyOf as LiteralKeyOf_alias_2 }

// @public
type LiteralUnion<LiteralType, BaseType extends Primitive> = (BaseType & Record<never, never>) | LiteralType;
export { LiteralUnion }
export { LiteralUnion as LiteralUnion_alias_1 }
export { LiteralUnion as LiteralUnion_alias_2 }

// @public (undocumented)
type MaybePromise<T> = T | Promise<T>;
export { MaybePromise }
export { MaybePromise as MaybePromise_alias_1 }
export { MaybePromise as MaybePromise_alias_2 }

// @public (undocumented)
type MessageDetails<TMessageType extends string = MessageType> = {
    code: string;
    message?: string;
    type: TMessageType;
} | {
    code?: string;
    message: string;
    type: TMessageType;
};
export { MessageDetails }
export { MessageDetails as MessageDetails_alias_1 }
export { MessageDetails as MessageDetails_alias_2 }

// @public (undocumented)
type MessageType = "error" | "info" | "success" | "warning";

// @public (undocumented)
const MessageType: {
    ERROR: MessageType;
    INFO: MessageType;
    SUCCESS: MessageType;
    WARNING: MessageType;
};
export { MessageType }
export { MessageType as MessageType_alias_1 }
export { MessageType as MessageType_alias_2 }

// @public (undocumented)
type Module = "CommonJS" | "AMD" | "System" | "UMD" | "ES6" | "ES2015" | "ES2020" | "ES2022" | "ESNext" | "Node16" | "NodeNext" | "Preserve" | "None" | "commonjs" | "amd" | "system" | "umd" | "es6" | "es2015" | "es2020" | "es2022" | "esnext" | "node16" | "nodenext" | "preserve" | "none";
export { Module }
export { Module as Module_alias_1 }
export { Module as Module_alias_2 }

// @public (undocumented)
type ModuleDetection = "auto" | "legacy" | "force";
export { ModuleDetection }
export { ModuleDetection as ModuleDetection_alias_1 }
export { ModuleDetection as ModuleDetection_alias_2 }

// @public (undocumented)
type ModuleResolution = "classic" | "node" | "node10" | "node16" | "nodenext" | "bundler" | "Classic" | "Node" | "Node10" | "Node16" | "NodeNext" | "Bundler";
export { ModuleResolution }
export { ModuleResolution as ModuleResolution_alias_1 }
export { ModuleResolution as ModuleResolution_alias_2 }

// @public (undocumented)
type Narrow<A> = Try<A, [], NarrowRaw<A>>;
export { Narrow }
export { Narrow as Narrow_alias_1 }
export { Narrow as Narrow_alias_2 }

// @public (undocumented)
type NativeClass = abstract new (...args: any) => any;
export { NativeClass }
export { NativeClass as NativeClass_alias_1 }
export { NativeClass as NativeClass_alias_2 }

// @public
export type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never;

// @public
export type NegativeFloat<T extends number> = Negative<Float<T>>;

// @public
export type NegativeInfinity = -1e999;

// @public
export type NegativeInteger<T extends number> = Negative<Integer<T>>;

// @public (undocumented)
type NestedValue<TValue extends object = object> = {
    [$NestedValue]: never;
} & TValue;
export { NestedValue }
export { NestedValue as NestedValue_alias_1 }
export { NestedValue as NestedValue_alias_2 }

// @public (undocumented)
type Newable<T> = new (..._args: never[]) => T;
export { Newable }
export { Newable as Newable_alias_1 }
export { Newable as Newable_alias_2 }

// @public (undocumented)
type NewLine = "CRLF" | "LF" | "crlf" | "lf";
export { NewLine }
export { NewLine as NewLine_alias_1 }
export { NewLine as NewLine_alias_2 }

// @public (undocumented)
const NEWLINE_STRING = "\r\n";
export { NEWLINE_STRING }
export { NEWLINE_STRING as NEWLINE_STRING_alias_1 }
export { NEWLINE_STRING as NEWLINE_STRING_alias_2 }

// @public (undocumented)
type NoInfer_2<T> = [T][T extends any ? 0 : never];
export { NoInfer_2 as NoInfer }
export { NoInfer_2 as NoInfer_alias_1 }
export { NoInfer_2 as NoInfer_alias_2 }

// @public
export type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : never;

// @public
export type NonNegativeInteger<T extends number> = NonNegative<Integer<T>>;

// @public (undocumented)
type NonNullishObject = object;
export { NonNullishObject }
export { NonNullishObject as NonNullishObject_alias_1 }
export { NonNullishObject as NonNullishObject_alias_2 }

// @public
type NonRecursiveType = BuiltIns | Function | (new (...arguments_: any[]) => unknown);
export { NonRecursiveType }
export { NonRecursiveType as NonRecursiveType_alias_1 }
export { NonRecursiveType as NonRecursiveType_alias_2 }

// @public (undocumented)
type NonUndefined<T> = T extends undefined ? never : T;
export { NonUndefined }
export { NonUndefined as NonUndefined_alias_1 }
export { NonUndefined as NonUndefined_alias_2 }

// @public
type Not<A extends boolean> = A extends true ? false : A extends false ? true : never;
export { Not }
export { Not as Not_alias_1 }
export { Not as Not_alias_2 }

// @public (undocumented)
type Nullable<T> = T | null;
export { Nullable }
export { Nullable as Nullable_alias_1 }
export { Nullable as Nullable_alias_2 }

// @public (undocumented)
type NullableDeepValue<TObject extends Record<string, unknown>, TPath extends DeepKey<TObject>> = Nullable<GetWithPath<TObject, ToPath<TPath>>>;
export { NullableDeepValue }
export { NullableDeepValue as NullableDeepValue_alias_1 }
export { NullableDeepValue as NullableDeepValue_alias_2 }

// @public (undocumented)
type Nullish = undefined | null;
export { Nullish }
export { Nullish as Nullish_alias_1 }
export { Nullish as Nullish_alias_2 }

// @public (undocumented)
type Nullishable<T> = T | Nullish;
export { Nullishable }
export { Nullishable as Nullishable_alias_1 }
export { Nullishable as Nullishable_alias_2 }

// @public
type NumberAbsolute<N extends number> = `${N}` extends `-${infer StringPositiveN}` ? StringToNumber<StringPositiveN> : N;
export { NumberAbsolute }
export { NumberAbsolute as NumberAbsolute_alias_1 }
export { NumberAbsolute as NumberAbsolute_alias_2 }

// @public (undocumented)
export type Numeric = number | bigint;

// @public
type ObjectValue<T, K> = K extends keyof T ? T[K] : ToString<K> extends keyof T ? T[ToString<K>] : K extends `${infer NumberK extends number}` ? NumberK extends keyof T ? T[NumberK] : never : never;
export { ObjectValue }
export { ObjectValue as ObjectValue_alias_1 }
export { ObjectValue as ObjectValue_alias_2 }

// @public (undocumented)
type Or<A extends boolean, B extends boolean> = [
A,
B
][number] extends false ? false : true extends [IsEqual<A, true>, IsEqual<B, true>][number] ? true : never;
export { Or }
export { Or as Or_alias_1 }
export { Or as Or_alias_2 }

// @public
type PackageJson = JsonObject & PackageJson_2.NodeJsStandard & PackageJson_2.PackageJsonStandard & PackageJson_2.NonStandardEntryPoints & PackageJson_2.TypeScriptConfiguration & PackageJson_2.YarnConfiguration & PackageJson_2.JSPMConfiguration;
export { PackageJson }
export { PackageJson as PackageJson_alias_1 }
export { PackageJson as PackageJson_alias_2 }

// @public (undocumented)
type Paths<T> = Paths_<T>;
export { Paths }
export { Paths as Paths_alias_1 }
export { Paths as Paths_alias_2 }

// @public
type PickDeep<T, PathUnion extends Paths<T>> = T extends NonRecursiveType ? never : T extends UnknownArray ? UnionToIntersection<{
    [P in PathUnion]: InternalPickDeep<T, P>;
}[PathUnion]> : T extends object ? Simplify<UnionToIntersection<{
    [P in PathUnion]: InternalPickDeep<T, P>;
}[PathUnion]>> : never;
export { PickDeep }
export { PickDeep as PickDeep_alias_1 }
export { PickDeep as PickDeep_alias_2 }

// @public (undocumented)
type PlainObject = Record<any, {}>;
export { PlainObject }
export { PlainObject as PlainObject_alias_1 }
export { PlainObject as PlainObject_alias_2 }

// @public (undocumented)
interface Plugin {
    name: string;
}
export { Plugin }
export { Plugin as Plugin_alias_1 }
export { Plugin as Plugin_alias_2 }

// @public (undocumented)
type PollingWatchKind = "FixedInterval" | "PriorityInterval" | "DynamicPriority" | "FixedChunkSize";
export { PollingWatchKind }
export { PollingWatchKind as PollingWatchKind_alias_1 }
export { PollingWatchKind as PollingWatchKind_alias_2 }

// @public
export type PositiveInfinity = 1e999;

// @public
type PositiveNumericCharacterGt<A extends string, B extends string> = NumericString extends `${infer HeadA}${A}${infer TailA}` ? NumericString extends `${infer HeadB}${B}${infer TailB}` ? HeadA extends `${HeadB}${infer _}${infer __}` ? true : false : never : never;
export { PositiveNumericCharacterGt }
export { PositiveNumericCharacterGt as PositiveNumericCharacterGt_alias_1 }
export { PositiveNumericCharacterGt as PositiveNumericCharacterGt_alias_2 }

// @public
type PositiveNumericStringGt<A extends string, B extends string> = A extends B ? false : [
BuildTuple<StringLength<A>, 0>,
BuildTuple<StringLength<B>, 0>
] extends infer R extends [readonly unknown[], readonly unknown[]] ? R[0] extends [...R[1], ...infer Remain extends readonly unknown[]] ? 0 extends Remain["length"] ? SameLengthPositiveNumericStringGt<A, B> : true : false : never;
export { PositiveNumericStringGt }
export { PositiveNumericStringGt as PositiveNumericStringGt_alias_1 }
export { PositiveNumericStringGt as PositiveNumericStringGt_alias_2 }

// @public (undocumented)
type Pretty<T> = {
    [K in keyof T]: T[K];
} & {};
export { Pretty }
export { Pretty as Pretty_alias_1 }
export { Pretty as Pretty_alias_2 }

// @public (undocumented)
type Primitive = SerializablePrimitive | symbol;
export { Primitive }
export { Primitive as Primitive_alias_1 }
export { Primitive as Primitive_alias_2 }

// @public (undocumented)
type ReducerFunction<TState, TAction> = (state: TState, action: TAction) => TState;
export { ReducerFunction }
export { ReducerFunction as ReducerFunction_alias_1 }
export { ReducerFunction as ReducerFunction_alias_2 }

// @public (undocumented)
interface References {
    circular?: boolean;
    originalPath?: string;
    path: string;
    // @deprecated
    prepend?: boolean;
}
export { References }
export { References as References_alias_1 }
export { References as References_alias_2 }

// @public (undocumented)
interface RefObject<T> {
    // (undocumented)
    current: T;
}
export { RefObject }
export { RefObject as RefObject_alias_1 }
export { RefObject as RefObject_alias_2 }

// @public (undocumented)
type RequiredByKey<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export { RequiredByKey }
export { RequiredByKey as RequiredByKey_alias_1 }
export { RequiredByKey as RequiredByKey_alias_2 }

// @public
type RequiredKeysOf<BaseType extends object> = Exclude<{
    [Key in keyof BaseType]: BaseType extends Record<Key, BaseType[Key]> ? Key : never;
}[keyof BaseType], undefined>;
export { RequiredKeysOf }
export { RequiredKeysOf as RequiredKeysOf_alias_1 }
export { RequiredKeysOf as RequiredKeysOf_alias_2 }

// @public (undocumented)
type Rollback = Record<string, (initialValue: any, currentValue: any) => any>;
export { Rollback }
export { Rollback as Rollback_alias_1 }
export { Rollback as Rollback_alias_2 }

// @public
type SameLengthPositiveNumericStringGt<A extends string, B extends string> = A extends `${infer FirstA}${infer RestA}` ? B extends `${infer FirstB}${infer RestB}` ? FirstA extends FirstB ? SameLengthPositiveNumericStringGt<RestA, RestB> : PositiveNumericCharacterGt<FirstA, FirstB> : never : false;
export { SameLengthPositiveNumericStringGt }
export { SameLengthPositiveNumericStringGt as SameLengthPositiveNumericStringGt_alias_1 }
export { SameLengthPositiveNumericStringGt as SameLengthPositiveNumericStringGt_alias_2 }

// @public (undocumented)
interface SelectOption<T = string> {
    disabled: boolean;
    name: T;
    selected: boolean;
    value: string | number | boolean;
}
export { SelectOption }
export { SelectOption as SelectOption_alias_1 }
export { SelectOption as SelectOption_alias_2 }

// @public (undocumented)
type SerializablePrimitive = null | undefined | string | number | boolean | bigint;
export { SerializablePrimitive }
export { SerializablePrimitive as SerializablePrimitive_alias_1 }
export { SerializablePrimitive as SerializablePrimitive_alias_2 }

// @public
type SetRequired<BaseType, Keys extends keyof BaseType> = BaseType extends unknown ? Simplify<Except<BaseType, Keys> & Required<Pick<BaseType, Keys>>> : never;
export { SetRequired }
export { SetRequired as SetRequired_alias_1 }
export { SetRequired as SetRequired_alias_2 }

// @public
type SetReturnType<Function_ extends (...arguments_: any[]) => any, TypeToReturn> = Function_ extends (this: infer ThisArgument, ...arguments_: infer Arguments) => any ? IsUnknown<ThisArgument> extends true ? (...arguments_: Arguments) => TypeToReturn : (this: ThisArgument, ...arguments_: Arguments) => TypeToReturn : (...arguments_: Parameters<Function_>) => TypeToReturn;
export { SetReturnType }
export { SetReturnType as SetReturnType_alias_1 }
export { SetReturnType as SetReturnType_alias_2 }

// @public
type Simplify<T> = {
    [KeyType in keyof T]: T[KeyType];
} & {};
export { Simplify }
export { Simplify as Simplify_alias_1 }
export { Simplify as Simplify_alias_2 }

// @public
type Split<S extends string, Delimiter extends string> = S extends `${infer Head}${Delimiter}${infer Tail}` ? [Head, ...Split<Tail, Delimiter>] : S extends Delimiter ? [] : [S];
export { Split }
export { Split as Split_alias_1 }
export { Split as Split_alias_2 }

// @public
type StartsWith<S extends string, SearchString extends string> = string extends S | SearchString ? never : S extends `${SearchString}${infer T}` ? true : false;
export { StartsWith }
export { StartsWith as StartsWith_alias_1 }
export { StartsWith as StartsWith_alias_2 }

// @public
type StaticPartOfArray<T extends UnknownArray, Result extends UnknownArray = []> = T extends unknown ? number extends T["length"] ? T extends readonly [infer U, ...infer V] ? StaticPartOfArray<V, [...Result, U]> : Result : T : never;
export { StaticPartOfArray }
export { StaticPartOfArray as StaticPartOfArray_alias_1 }
export { StaticPartOfArray as StaticPartOfArray_alias_2 }

// @public (undocumented)
type StringDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
export { StringDigit }
export { StringDigit as StringDigit_alias_1 }
export { StringDigit as StringDigit_alias_2 }

// @public
type Stringified<ObjectType> = {
    [KeyType in keyof ObjectType]: string;
};
export { Stringified }
export { Stringified as Stringified_alias_1 }
export { Stringified as Stringified_alias_2 }

// @public
type StringKeyOf<BaseType> = `${Extract<keyof BaseType, string | number>}`;
export { StringKeyOf }
export { StringKeyOf as StringKeyOf_alias_1 }
export { StringKeyOf as StringKeyOf_alias_2 }

// @public
type StringLength<S extends string> = string extends S ? never : StringToArray<S>["length"];
export { StringLength }
export { StringLength as StringLength_alias_1 }
export { StringLength as StringLength_alias_2 }

// @public
type StringToArray<S extends string, Result extends string[] = []> = string extends S ? never : S extends `${infer F}${infer R}` ? StringToArray<R, [...Result, F]> : Result;
export { StringToArray }
export { StringToArray as StringToArray_alias_1 }
export { StringToArray as StringToArray_alias_2 }

// @public
type StringToNumber<S extends string> = S extends `${infer N extends number}` ? N : S extends "Infinity" ? PositiveInfinity : S extends "-Infinity" ? NegativeInfinity : never;
export { StringToNumber }
export { StringToNumber as StringToNumber_alias_1 }
export { StringToNumber as StringToNumber_alias_2 }

// @public
type StructuredCloneable = StructuredCloneablePrimitive | StructuredCloneableData | StructuredCloneableCollection;
export { StructuredCloneable }
export { StructuredCloneable as StructuredCloneable_alias_1 }
export { StructuredCloneable as StructuredCloneable_alias_2 }

// @public (undocumented)
type Subtract<A extends number, B extends number> = number extends A | B ? number : [
IsEqual<A, PositiveInfinity>,
IsEqual<A, NegativeInfinity>,
IsEqual<B, PositiveInfinity>,
IsEqual<B, NegativeInfinity>
] extends infer R extends [boolean, boolean, boolean, boolean] ? Or<And<IsEqual<R[0], true>, IsEqual<R[2], false>>, And<IsEqual<R[3], true>, IsEqual<R[1], false>>> extends true ? PositiveInfinity : Or<And<IsEqual<R[1], true>, IsEqual<R[3], false>>, And<IsEqual<R[2], true>, IsEqual<R[0], false>>> extends true ? NegativeInfinity : true extends R[number] ? number : [IsNegative<A>, IsNegative<B>] extends infer R ? [false, false] extends R ? BuildTuple<A> extends infer R ? R extends [...BuildTuple<B>, ...infer R] ? R["length"] : number : never : LessThan<A, B> extends true ? number : [false, true] extends R ? Sum<A, NumberAbsolute<B>> : Subtract<NumberAbsolute<B>, NumberAbsolute<A>> : never : never;
export { Subtract }
export { Subtract as Subtract_alias_1 }
export { Subtract as Subtract_alias_2 }

// @public (undocumented)
type SuccessMessageDetails = {
    type: "success";
} & Omit<MessageDetails, "type">;
export { SuccessMessageDetails }
export { SuccessMessageDetails as SuccessMessageDetails_alias_1 }
export { SuccessMessageDetails as SuccessMessageDetails_alias_2 }

// @public (undocumented)
type Sum<A extends number, B extends number> = number extends A | B ? number : [
IsEqual<A, PositiveInfinity>,
IsEqual<A, NegativeInfinity>,
IsEqual<B, PositiveInfinity>,
IsEqual<B, NegativeInfinity>
] extends infer R extends [boolean, boolean, boolean, boolean] ? Or<And<IsEqual<R[0], true>, IsEqual<R[3], false>>, And<IsEqual<R[2], true>, IsEqual<R[1], false>>> extends true ? PositiveInfinity : Or<And<IsEqual<R[1], true>, IsEqual<R[2], false>>, And<IsEqual<R[3], true>, IsEqual<R[0], false>>> extends true ? NegativeInfinity : true extends R[number] ? number : ([IsNegative<A>, IsNegative<B>] extends infer R ? [false, false] extends R ? [...BuildTuple<A>, ...BuildTuple<B>]["length"] : [true, true] extends R ? number : ArrayMax<[
NumberAbsolute<A>,
NumberAbsolute<B>
]> extends infer Max_ ? ArrayMin<[
NumberAbsolute<A>,
NumberAbsolute<B>
]> extends infer Min_ extends number ? Max_ extends A | B ? Subtract<Max_, Min_> : number : never : never : never) & number : never;
export { Sum }
export { Sum as Sum_alias_1 }
export { Sum as Sum_alias_2 }

// @public (undocumented)
type Target = "ES3" | "ES5" | "ES6" | "ES2015" | "ES2016" | "ES2017" | "ES2018" | "ES2019" | "ES2020" | "ES2021" | "ES2022" | "ESNext" | "es3" | "es5" | "es6" | "es2015" | "es2016" | "es2017" | "es2018" | "es2019" | "es2020" | "es2021" | "es2022" | "esnext";
export { Target }
export { Target as Target_alias_1 }
export { Target as Target_alias_2 }

// @public
type ToPath<S extends string> = Split<FixPathSquareBrackets<S>, ".">;
export { ToPath }
export { ToPath as ToPath_alias_1 }
export { ToPath as ToPath_alias_2 }

// @public
type ToString<T> = T extends number | string ? `${T}` : never;
export { ToString }
export { ToString as ToString_alias_1 }
export { ToString as ToString_alias_2 }

// @public (undocumented)
type Try<A1, A2, Catch = never> = A1 extends A2 ? A1 : Catch;
export { Try }
export { Try as Try_alias_1 }
export { Try as Try_alias_2 }

// @public
interface TsConfigJson {
    compileOnSave?: boolean;
    compilerOptions?: CompilerOptions;
    exclude?: string[];
    extends?: string | string[];
    files?: string[];
    include?: string[];
    references?: References[];
    typeAcquisition?: TypeAcquisition;
    watchOptions?: WatchOptions;
}
export { TsConfigJson }
export { TsConfigJson as TsConfigJson_alias_1 }
export { TsConfigJson as TsConfigJson_alias_2 }

// @public (undocumented)
const TYPE_ARGUMENTS = "Arguments";
export { TYPE_ARGUMENTS }
export { TYPE_ARGUMENTS as TYPE_ARGUMENTS_alias_1 }
export { TYPE_ARGUMENTS as TYPE_ARGUMENTS_alias_2 }

// @public (undocumented)
const TYPE_ARRAY = "Array";
export { TYPE_ARRAY }
export { TYPE_ARRAY as TYPE_ARRAY_alias_1 }
export { TYPE_ARRAY as TYPE_ARRAY_alias_2 }

// @public (undocumented)
const TYPE_MAP = "Map";
export { TYPE_MAP }
export { TYPE_MAP as TYPE_MAP_alias_1 }
export { TYPE_MAP as TYPE_MAP_alias_2 }

// @public (undocumented)
const TYPE_OBJECT = "Object";
export { TYPE_OBJECT }
export { TYPE_OBJECT as TYPE_OBJECT_alias_1 }
export { TYPE_OBJECT as TYPE_OBJECT_alias_2 }

// @public (undocumented)
const TYPE_SET = "Set";
export { TYPE_SET }
export { TYPE_SET as TYPE_SET_alias_1 }
export { TYPE_SET as TYPE_SET_alias_2 }

// @public
interface TypeAcquisition {
    enable?: boolean;
    exclude?: string[];
    include?: string[];
}
export { TypeAcquisition }
export { TypeAcquisition as TypeAcquisition_alias_1 }
export { TypeAcquisition as TypeAcquisition_alias_2 }

// @public
type TypedArray = BigInt64Array | BigUint64Array | Float32Array | Float64Array | Int8Array | Int16Array | Int32Array | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;
export { TypedArray }
export { TypedArray as TypedArray_alias_1 }
export { TypedArray as TypedArray_alias_2 }

// @public
type TypeMap = Record<string, TypeTester>;
export { TypeMap }
export { TypeMap as TypeMap_alias_1 }
export { TypeMap as TypeMap_alias_2 }

// @public
type TypeTester = (value: any) => boolean;
export { TypeTester }
export { TypeTester as TypeTester_alias_1 }
export { TypeTester as TypeTester_alias_2 }

// @public
type UnionToIntersection<Union> = (Union extends unknown ? (_distributedUnion: Union) => void : never) extends (_mergedIntersection: infer Intersection) => void ? // The `& Union` is to allow indexing by the resulting type
Intersection & Union : never;
export { UnionToIntersection }
export { UnionToIntersection as UnionToIntersection_alias_1 }
export { UnionToIntersection as UnionToIntersection_alias_2 }

// @public (undocumented)
type UnknownArray = readonly unknown[];
export { UnknownArray }
export { UnknownArray as UnknownArray_alias_1 }
export { UnknownArray as UnknownArray_alias_2 }

// @public
type UnknownArrayOrTuple = readonly [...unknown[]];
export { UnknownArrayOrTuple }
export { UnknownArrayOrTuple as UnknownArrayOrTuple_alias_1 }
export { UnknownArrayOrTuple as UnknownArrayOrTuple_alias_2 }

// @public (undocumented)
type UpperCaseCharacters = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
export { UpperCaseCharacters }
export { UpperCaseCharacters as UpperCaseCharacters_alias_1 }
export { UpperCaseCharacters as UpperCaseCharacters_alias_2 }

// @public
type VariablePartOfArray<T extends UnknownArray> = T extends unknown ? T extends readonly [...StaticPartOfArray<T>, ...infer U] ? U : [] : never;
export { VariablePartOfArray }
export { VariablePartOfArray as VariablePartOfArray_alias_1 }
export { VariablePartOfArray as VariablePartOfArray_alias_2 }

// @public (undocumented)
type WarningMessageDetails = {
    type: "warning";
} & Omit<MessageDetails, "type">;
export { WarningMessageDetails }
export { WarningMessageDetails as WarningMessageDetails_alias_1 }
export { WarningMessageDetails as WarningMessageDetails_alias_2 }

// @public (undocumented)
type WatchDirectory = "useFsEvents" | "fixedPollingInterval" | "dynamicPriorityPolling" | "fixedChunkSizePolling";
export { WatchDirectory }
export { WatchDirectory as WatchDirectory_alias_1 }
export { WatchDirectory as WatchDirectory_alias_2 }

// @public (undocumented)
type WatchDirectoryKind = "UseFsEvents" | "FixedPollingInterval" | "DynamicPriorityPolling" | "FixedChunkSizePolling";
export { WatchDirectoryKind }
export { WatchDirectoryKind as WatchDirectoryKind_alias_1 }
export { WatchDirectoryKind as WatchDirectoryKind_alias_2 }

// @public (undocumented)
type WatchFile = "fixedPollingInterval" | "priorityPollingInterval" | "dynamicPriorityPolling" | "useFsEvents" | "useFsEventsOnParentDirectory" | "fixedChunkSizePolling";
export { WatchFile }
export { WatchFile as WatchFile_alias_1 }
export { WatchFile as WatchFile_alias_2 }

// @public (undocumented)
type WatchFileKind = "FixedPollingInterval" | "PriorityPollingInterval" | "DynamicPriorityPolling" | "FixedChunkSizePolling" | "UseFsEvents" | "UseFsEventsOnParentDirectory";
export { WatchFileKind }
export { WatchFileKind as WatchFileKind_alias_1 }
export { WatchFileKind as WatchFileKind_alias_2 }

// @public (undocumented)
interface WatchOptions {
    excludeDirectories?: string[];
    excludeFiles?: string[];
    fallbackPolling?: PollingWatchKind | Lowercase<PollingWatchKind>;
    synchronousWatchDirectory?: boolean;
    watchDirectory?: WatchDirectoryKind | Lowercase<WatchDirectoryKind>;
    watchFile?: WatchFileKind | Lowercase<WatchFileKind>;
}
export { WatchOptions }
export { WatchOptions as WatchOptions_alias_1 }
export { WatchOptions as WatchOptions_alias_2 }

// @public (undocumented)
type Whitespace = "\u{9}" | "\u{A}" | "\u{B}" | "\u{C}" | "\u{D}" | "\u{20}" | "\u{85}" | "\u{A0}" | "\u{1680}" | "\u{2000}" | "\u{2001}" | "\u{2002}" | "\u{2003}" | "\u{2004}" | "\u{2005}" | "\u{2006}" | "\u{2007}" | "\u{2008}" | "\u{2009}" | "\u{200A}" | "\u{2028}" | "\u{2029}" | "\u{202F}" | "\u{205F}" | "\u{3000}" | "\u{FEFF}";
export { Whitespace }
export { Whitespace as Whitespace_alias_1 }
export { Whitespace as Whitespace_alias_2 }

// @public (undocumented)
type WordSeparators = "-" | "_" | Whitespace;
export { WordSeparators }
export { WordSeparators as WordSeparators_alias_1 }
export { WordSeparators as WordSeparators_alias_2 }

// @public (undocumented)
export type Zero = 0 | 0n;

// (No @packageDocumentation comment for this package)

```
