## API Report File for "@storm-stack/plugin-system"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ExecaReturnValue } from 'execa';
import { Temporal } from '@js-temporal/polyfill';

// @public
const createResolver: (rootPath?: string, tsconfig?: string, autoInstall?: boolean) => ((request: string) => Promise<string>);
export { createResolver }
export { createResolver as createResolver_alias_1 }
export { createResolver as createResolver_alias_2 }

// @public (undocumented)
export const execute: (command: string, rootPath: string) => Promise<ExecaReturnValue<string>>;

// @public (undocumented)
export const install: (name: string, rootPath: string) => Promise<void>;

// @public
interface IPluginLoader<TContext = any, TPluginModule extends IPluginModule<TContext> = IPluginModule<TContext>> {
    // (undocumented)
    isValid: (module: TPluginModule) => boolean;
    // (undocumented)
    load: (definition: PluginDefinition, options: Record<string, any>) => Promise<PluginInstance<TContext, TPluginModule>>;
    // (undocumented)
    process: (context: TContext, instance: PluginInstance, options: Record<string, any>) => Promise<void>;
}
export { IPluginLoader }
export { IPluginLoader as IPluginLoader_alias_1 }

// @public
interface IPluginManager {
    discover(): Promise<Set<PluginDefinition>>;
    instantiate(provider: string, options?: Record<string, any>): Promise<PluginInstance>;
    register(provider: string): boolean;
}
export { IPluginManager }
export { IPluginManager as IPluginManager_alias_1 }

// @public
interface IPluginModule<TContext = any> {
    // (undocumented)
    hooks?: Record<string, PluginHookFn<TContext>>;
}
export { IPluginModule }
export { IPluginModule as IPluginModule_alias_1 }

// @public
interface PluginDefinition {
    configPath?: string;
    dependencies: string[];
    description?: string;
    id: string;
    imagePath?: string;
    loader: string;
    name: string;
    options: any;
    packagePath: string;
    provider: string;
    tags: string[];
    version: string;
}
export { PluginDefinition }
export { PluginDefinition as PluginDefinition_alias_1 }

// @public (undocumented)
type PluginDiscoveryMode = "auto" | "fallback" | "none";

// @public (undocumented)
const PluginDiscoveryMode: {
    AUTO: PluginDiscoveryMode;
    FALLBACK: PluginDiscoveryMode;
    NONE: PluginDiscoveryMode;
};
export { PluginDiscoveryMode }
export { PluginDiscoveryMode as PluginDiscoveryMode_alias_1 }

// @public
type PluginHookFn<TContext = any> = (params: TContext) => MaybePromise<TContext | ((params: TContext) => MaybePromise<TContext>)>;
export { PluginHookFn }
export { PluginHookFn as PluginHookFn_alias_1 }

// @public
interface PluginInstance<TContext = any, TPluginModule extends IPluginModule<TContext> = any> {
    // (undocumented)
    definition: PluginDefinition;
    // (undocumented)
    executionDateTime: StormDateTime;
    // (undocumented)
    loader: IPluginLoader<TContext, TPluginModule>;
    // (undocumented)
    module: TPluginModule;
    // (undocumented)
    options: any;
    // (undocumented)
    resolvedPath: string;
}
export { PluginInstance }
export { PluginInstance as PluginInstance_alias_1 }

// @public
abstract class PluginLoader<TContext = any, TPluginModule extends IPluginModule<TContext> = IPluginModule<TContext>> implements IPluginLoader<TContext, TPluginModule> {
    constructor(rootPath?: string | undefined, tsconfig?: string | undefined, autoInstall?: boolean | undefined);
    // (undocumented)
    readonly autoInstall?: boolean | undefined;
    // (undocumented)
    protected instantiate: (definition: PluginDefinition, module: TPluginModule, resolvedPath: string, options?: Record<string, any>) => PluginInstance<TContext, TPluginModule>;
    // (undocumented)
    isValid: (module: TPluginModule) => boolean;
    // (undocumented)
    load: (definition: PluginDefinition, options?: Record<string, any>) => Promise<PluginInstance<TContext, TPluginModule>>;
    // (undocumented)
    abstract process: (context: TContext, instance: PluginInstance<TContext, TPluginModule>, options: Record<string, any>) => Promise<void>;
    // (undocumented)
    protected resolve: (definition: PluginDefinition, _?: Record<string, any>) => Promise<any>;
    // (undocumented)
    protected resolver: (request: string) => Promise<string>;
    // (undocumented)
    readonly rootPath?: string | undefined;
    // (undocumented)
    readonly tsconfig?: string | undefined;
}
export { PluginLoader }
export { PluginLoader as PluginLoader_alias_1 }
export { PluginLoader as PluginLoader_alias_2 }

// @public
class PluginManager<TContext = any, TPluginModule extends IPluginModule = any> {
    // (undocumented)
    static create: <TContext_1 = any, TPluginModule_1 extends IPluginModule<TContext_1> = any>(logger: IStormLog, options: Omit<Partial<PluginManagerOptions>, "defaultLoader"> & Pick<PluginManagerOptions, "defaultLoader">) => Promise<PluginManager<TContext_1, TPluginModule_1>>;
    // (undocumented)
    discover: () => Promise<Map<string, PluginDefinition>>;
    // (undocumented)
    execute: (provider: string, context: TContext, options?: Record<string, any>, executionDateTime?: StormDateTime) => Promise<Record<string, Error | null>>;
    // (undocumented)
    getInstance: (provider: string, options?: Record<string, any>) => PluginInstance<TContext, TPluginModule> | undefined;
    // (undocumented)
    getLoaders(): Map<string, IPluginLoader<TContext, TPluginModule>>;
    // (undocumented)
    getRegistry(): Map<string, PluginDefinition>;
    // (undocumented)
    getStore(): Map<string, PluginInstance<TContext, TPluginModule>>;
    // (undocumented)
    instantiate: (provider: string, options?: Record<string, any>) => Promise<PluginInstance<TContext, TPluginModule>>;
    // (undocumented)
    invokeHook: (name: string, context: TContext, handler?: (context: TContext) => Promise<TContext> | TContext) => Promise<TContext>;
    // (undocumented)
    register: (provider: string) => Promise<PluginDefinition>;
}
export { PluginManager }
export { PluginManager as PluginManager_alias_1 }
export { PluginManager as PluginManager_alias_2 }

// @public
interface PluginManagerOptions {
    autoInstall: boolean;
    defaultLoader: string | {
        provider: string;
        loader: new (_rootPath?: string, _tsconfig?: string, _autoInstall?: boolean) => IPluginLoader<any, any>;
    };
    discoveryMode: PluginDiscoveryMode;
    rootPath: string;
    tsconfig?: string;
    useNodeModules: boolean;
}
export { PluginManagerOptions }
export { PluginManagerOptions as PluginManagerOptions_alias_1 }

// @public (undocumented)
type PluginSystemErrorCode = ErrorCode | "module_not_found" | "plugin_not_found" | "plugin_loading_failure";

// @public (undocumented)
const PluginSystemErrorCode: {
    module_not_found: PluginSystemErrorCode;
    plugin_not_found: PluginSystemErrorCode;
    plugin_loading_failure: PluginSystemErrorCode;
    success: ErrorCode;
    missing_issue_code: ErrorCode;
    invalid_config: ErrorCode;
    failed_to_load_file: ErrorCode;
    missing_context: ErrorCode;
    record_not_found: ErrorCode;
    required_field_missing: ErrorCode;
    database_query_error: ErrorCode;
    model_validation_error: ErrorCode;
    field_validation_error: ErrorCode;
    invalid_parameter: ErrorCode;
    invalid_request: ErrorCode;
    type_error: ErrorCode;
    processing_error: ErrorCode;
    internal_server_error: ErrorCode;
    user_not_logged_in: ErrorCode;
    unknown_cause: ErrorCode;
};
export { PluginSystemErrorCode }
export { PluginSystemErrorCode as PluginSystemErrorCode_alias_1 }

// (No @packageDocumentation comment for this package)

```
