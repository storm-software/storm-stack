## API Report File for "@storm-stack/unique-identifier"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
// @public (undocumented)
type Class = {
  new (...args: any[]): any;
};
export { Class };
export { Class as Class_alias_1 };

// @public (undocumented)
type ClassInstance = any;
export { ClassInstance };
export { ClassInstance as ClassInstance_alias_1 };

// @public
interface ClassSerializable<TData, TJsonValue extends JsonValue = JsonValue> {
  deserialize: (json: TJsonValue) => void;
  serialize: () => TJsonValue;
}
export { ClassSerializable };
export { ClassSerializable as ClassSerializable_alias_1 };

// @public (undocumented)
type ClassTypeAnnotation = ["class", string];
export { ClassTypeAnnotation };
export { ClassTypeAnnotation as ClassTypeAnnotation_alias_1 };

// @public (undocumented)
type CompositeTypeAnnotation =
  | TypedArrayAnnotation
  | ClassTypeAnnotation
  | SymbolTypeAnnotation
  | CustomTypeAnnotation;
export { CompositeTypeAnnotation };
export { CompositeTypeAnnotation as CompositeTypeAnnotation_alias_1 };

// @public (undocumented)
type CustomTypeAnnotation = ["custom", string];
export { CustomTypeAnnotation };
export { CustomTypeAnnotation as CustomTypeAnnotation_alias_1 };

// @public
interface DataTransformer<TData, TJsonValue extends JsonValue = JsonValue> {
  deserialize: DeserializeFunct<TData, TJsonValue>;
  serialize: SerializationFunct<TData, TJsonValue>;
}
export { DataTransformer };
export { DataTransformer as DataTransformer_alias_1 };

// @public
function deserialize<TData = unknown>(payload: JsonParserResult): TData;
export { deserialize };
export { deserialize as deserialize_alias_1 };

// @public
type DeserializeFunct<TData = any, TJsonValue extends JsonValue = JsonValue> = (
  json: TJsonValue
) => TData;
export { DeserializeFunct };
export { DeserializeFunct as DeserializeFunct_alias_1 };

// @public (undocumented)
interface IJsonParser {
  // (undocumented)
  deserialize: <TData = any>(payload: JsonParserResult) => TData;
  // (undocumented)
  parse: <TData = any>(strData: string) => TData;
  // (undocumented)
  register: <TData = any, TJsonValue extends JsonValue = JsonValue>(
    name: string,
    serialize: (object: JsonValue) => TJsonValue,
    deserialize: (payload: TJsonValue) => TData,
    isApplicable: (data: any) => data is TData
  ) => void;
  // (undocumented)
  serialize: (object: JsonValue) => JsonParserResult;
  // (undocumented)
  stringify: <TData = any>(data: TData) => string;
}
export { IJsonParser };
export { IJsonParser as IJsonParser_alias_1 };

// @public (undocumented)
type InnerNode<T> = [T, Record<string, Tree<T>>];
export { InnerNode };
export { InnerNode as InnerNode_alias_1 };

// @public (undocumented)
interface JsonArray extends Array<JsonValue> {}
export { JsonArray };
export { JsonArray as JsonArray_alias_1 };

// @public (undocumented)
interface JsonObject {
  // (undocumented)
  [key: string]: JsonValue;
}
export { JsonObject };
export { JsonObject as JsonObject_alias_1 };

// @public (undocumented)
interface JsonParserResult {
  // (undocumented)
  json: JsonValue;
  // (undocumented)
  meta?: {
    values?:
      | Tree<TypeAnnotation>
      | Record<string, Tree<TypeAnnotation>>
      | undefined;
    referentialEqualities?:
      | Record<string, string[]>
      | [string[]]
      | [string[], Record<string, string[]>];
  };
}
export { JsonParserResult };
export { JsonParserResult as JsonParserResult_alias_1 };

// @public (undocumented)
type JsonValue = PrimitiveJsonValue | JsonArray | JsonObject;
export { JsonValue };
export { JsonValue as JsonValue_alias_1 };

// @public (undocumented)
type Leaf<T> = [T];
export { Leaf };
export { Leaf as Leaf_alias_1 };

// @public (undocumented)
type LeafTypeAnnotation =
  | PrimitiveTypeAnnotation
  | "regexp"
  | "Date"
  | "Error"
  | "URL";
export { LeafTypeAnnotation };
export { LeafTypeAnnotation as LeafTypeAnnotation_alias_1 };

// @public
function parse<TData = unknown>(strData: string): TData;
export { parse };
export { parse as parse_alias_1 };

// @public
function parseQueryParam<TData = unknown>(
  strData: string,
  options?: {
    comma?: boolean | undefined;
    delimiter?: string | RegExp | undefined;
    depth?: number | false | undefined;
    arrayLimit?: number | undefined;
    parseArrays?: boolean | undefined;
    allowDots?: boolean | undefined;
    plainObjects?: boolean | undefined;
    allowPrototypes?: boolean | undefined;
    parameterLimit?: number | undefined;
    strictNullHandling?: boolean | undefined;
    ignoreQueryPrefix?: boolean | undefined;
    charset?: "utf-8" | "iso-8859-1" | undefined;
    charsetSentinel?: boolean | undefined;
    interpretNumericEntities?: boolean | undefined;
  }
): TData;
export { parseQueryParam };
export { parseQueryParam as parseQueryParam_alias_1 };

// @public (undocumented)
type PrimitiveJsonValue = string | number | boolean | undefined | null;
export { PrimitiveJsonValue };
export { PrimitiveJsonValue as PrimitiveJsonValue_alias_1 };

// @public (undocumented)
type PrimitiveTypeAnnotation = "number" | "undefined" | "bigint";
export { PrimitiveTypeAnnotation };
export { PrimitiveTypeAnnotation as PrimitiveTypeAnnotation_alias_1 };

// @public (undocumented)
function register<TData = any, TJsonObject extends JsonValue = JsonValue>(
  name: string,
  serialize: (data: TData) => TJsonObject,
  deserialize: (json: TJsonObject) => TData,
  isApplicable: (data: any) => data is TData
): void;
export { register };
export { register as register_alias_1 };

// @public (undocumented)
const Serializable: <TData = any>(options: {
  name?: string | undefined;
  serialize: SerializationFunct<TData>;
  deserialize: DeserializeFunct<TData>;
}) => <TClass extends new (...args: any) => any = new (...args: any) => TData>(
  target: TClass
) => {
  new (...args: any): {
    [x: string]: any;
    __typename: string;
    serialize: () => JsonValue;
    deserialize: (json: JsonValue) => void;
    isTypeOf(value: any): value is TData;
  };
} & TClass;
export { Serializable };
export { Serializable as Serializable_alias_1 };

// @public (undocumented)
type SerializableJsonValue =
  | Symbol
  | Set<JsonValue>
  | Map<JsonValue, JsonValue>
  | undefined
  | bigint
  | Date
  | ClassInstance
  | RegExp;
export { SerializableJsonValue };
export { SerializableJsonValue as SerializableJsonValue_alias_1 };

// @public (undocumented)
type SerializableType<T> = ClassSerializable<T> &
  ClassTypeCheckable<T> &
  ITyped &
  T;
export { SerializableType };
export { SerializableType as SerializableType_alias_1 };

// @public
type SerializationFunct<
  TData = any,
  TJsonValue extends JsonValue = JsonValue
> = (data: TData) => TJsonValue;
export { SerializationFunct };
export { SerializationFunct as SerializationFunct_alias_1 };

// @public (undocumented)
type SerializationMetadata<T> = DataTransformer<T> & ClassTypeCheckable<T>;
export { SerializationMetadata };
export { SerializationMetadata as SerializationMetadata_alias_1 };

// @public
function serialize(object: JsonValue): JsonParserResult;
export { serialize };
export { serialize as serialize_alias_1 };

// @public (undocumented)
type SimpleTypeAnnotation = LeafTypeAnnotation | "map" | "set";
export { SimpleTypeAnnotation };
export { SimpleTypeAnnotation as SimpleTypeAnnotation_alias_1 };

// @public
function stringify(json: any): string;
export { stringify };
export { stringify as stringify_alias_1 };

// @public
function stringifyQueryParam(
  json: JsonValue,
  options?: {
    delimiter?: string | undefined;
    strictNullHandling?: boolean | undefined;
    skipNulls?: boolean | undefined;
    encode?: boolean | undefined;
    filter?:
      | Array<string | number>
      | ((prefix: string, value: any) => any)
      | undefined;
    arrayFormat?: "indices" | "brackets" | "repeat" | "comma" | undefined;
    indices?: boolean | undefined;
    sort?: ((a: any, b: any) => number) | undefined;
    serializeDate?: ((d: Date) => string) | undefined;
    format?: "RFC1738" | "RFC3986" | undefined;
    encodeValuesOnly?: boolean | undefined;
    addQueryPrefix?: boolean | undefined;
    charset?: "utf-8" | "iso-8859-1" | undefined;
    allowDots?: boolean | undefined;
    charsetSentinel?: boolean | undefined;
  }
): string;
export { stringifyQueryParam };
export { stringifyQueryParam as stringifyQueryParam_alias_1 };

// @public (undocumented)
type SymbolTypeAnnotation = ["symbol", string];
export { SymbolTypeAnnotation };
export { SymbolTypeAnnotation as SymbolTypeAnnotation_alias_1 };

// @public (undocumented)
type Tree<T> = InnerNode<T> | Leaf<T>;
export { Tree };
export { Tree as Tree_alias_1 };

// @public (undocumented)
type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;
export { TypeAnnotation };
export { TypeAnnotation as TypeAnnotation_alias_1 };

// @public (undocumented)
type TypedArrayAnnotation = ["typed-array", string];
export { TypedArrayAnnotation };
export { TypedArrayAnnotation as TypedArrayAnnotation_alias_1 };

// (No @packageDocumentation comment for this package)
```
