/*-------------------------------------------------------------------

                  âš¡ Storm Software - Storm Stack

 This code was released as part of the Storm Stack project. Storm Stack
 is maintained by Storm Software under the Apache-2.0 License, and is
 free for commercial and private use. For more information, please visit
 our licensing page.

 Website:         https://stormsoftware.com
 Repository:      https://github.com/storm-software/storm-stack
 Documentation:   https://stormsoftware.com/projects/storm-stack/docs
 Contact:         https://stormsoftware.com/contact
 License:         https://stormsoftware.com/projects/storm-stack/license

 -------------------------------------------------------------------*/

import { slash, throttle, toArray } from "@antfu/utils";
import { createFilter } from "@rollup/pluginutils";
import { isPackageExists } from "local-pkg";
import MagicString from "magic-string";
import { existsSync, promises as fs } from "node:fs";
import { dirname, isAbsolute, relative, resolve } from "node:path";
import process from "node:process";
import type { Import, InlinePreset } from "unimport";
import { createUnimport, resolvePreset } from "unimport";
import { presets } from "../presets";
import type { BiomeLintrc, ESLint, ImportExtended, Options } from "../types";
import { generateBiomeLintConfigs } from "./biomelintrc";
import { generateESLintFlatConfigs, generateESLintrcConfigs } from "./eslint";
import { resolversAddon } from "./resolvers";

export function createContext(options: Options = {}, rootDir = process.cwd()) {
  let root = slash(rootDir);

  const {
    dts: preferDTS = isPackageExists("typescript"),
    dirsScanOptions,
    dirs,
    vueDirectives,
    vueTemplate
  } = options;

  const eslint: ESLint = options.eslint ?? {};
  eslint.enabled = eslint.enabled ?? false;
  eslint.eslintrcFilepath =
    eslint.enabled === true || eslint.enabled === "eslintrc"
      ? eslint.eslintrcFilepath || "./.eslintrc-storm-stack.json"
      : undefined;
  eslint.eslintFlatFilepath =
    eslint.enabled === true || eslint.enabled === "eslint-flat"
      ? eslint.eslintFlatFilepath || "./eslint-storm-stack.config.js"
      : undefined;
  eslint.globalsPropValue = eslint.globalsPropValue ?? true;

  const biomelintrc: BiomeLintrc = options.biomelintrc ?? {};
  biomelintrc.enabled = biomelintrc.enabled !== undefined;
  biomelintrc.filepath =
    biomelintrc.filepath || "./.biomelintrc-storm-stack.json";

  const dumpUnimportItems =
    options.dumpUnimportItems === true
      ? "./.unimport-items.json"
      : (options.dumpUnimportItems ?? false);

  // eslint-disable-next-line unicorn/no-magic-array-flat-depth
  const resolvers = options.resolvers ? [options.resolvers].flat(2) : [];

  // When "options.injectAtEnd" is undefined or true, it's true.
  const injectAtEnd = options.injectAtEnd !== false;

  const unimport = createUnimport({
    imports: [],
    presets:
      options.packagePresets?.map(p =>
        typeof p === "string" ? { package: p } : p
      ) ?? [],
    dirsScanOptions: {
      ...dirsScanOptions,
      cwd: root
    },
    dirs,
    injectAtEnd,
    parser: options.parser,
    addons: {
      addons: [
        resolversAddon(resolvers),
        {
          name: "unplugin-storm-stack:dts",
          declaration(dts) {
            return `${`
/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-storm-stack
// biome-ignore lint: disable
${dts}`.trim()}\n`;
          }
        }
      ],
      vueDirectives,
      vueTemplate
    }
  });

  const importsPromise = flattenImports(options.imports).then(imports => {
    if (imports.length === 0 && resolvers.length === 0 && !dirs?.length) {
      // eslint-disable-next-line no-console
      console.warn(
        "[storm-stack] plugin installed but no imports has defined, see https://github.com/antfu/unplugin-auto-import#configurations for configurations"
      );
    }

    const compare = (
      left: string | undefined,
      right: NonNullable<Options["ignore"] | Options["ignoreDts"]>[number]
    ) => {
      return right instanceof RegExp ? right.test(left!) : right === left;
    };

    if (options.ignore) {
      for (const name of options.ignore) {
        const i = imports.find(i => compare(i.as, name));
        if (i) i.disabled = true;
      }
    }

    if (options.ignoreDts) {
      for (const name of options.ignoreDts) {
        const i = imports.find(i => compare(i.as, name));
        if (i) i.dtsDisabled = true;
      }
    }

    return unimport.getInternalContext().replaceImports(imports);
  });

  const filter = createFilter(
    options.include || [
      /\.[jt]sx?$/,
      /\.astro$/,
      /\.vue$/,
      /\.vue\?vue/,
      /\.svelte$/
    ],
    options.exclude || [/[/\\]node_modules[/\\]/, /[/\\]\.git[/\\]/]
  );
  const dts =
    preferDTS === false
      ? false
      : preferDTS === true
        ? resolve(root, "storm-stack.d.ts")
        : resolve(root, preferDTS);

  const multilineCommentsRE = /\/\*.*?\*\//gs;
  const singlelineCommentsRE = /\/\/.*$/gm;
  const dtsReg = /declare\s+global\s*{(?<temp1>.*?)[\n\r]}/s;
  const componentCustomPropertiesReg =
    /interface\s+ComponentCustomProperties\s*{(?<temp1>.*?)[\n\r]}/gs;
  function parseDTS(param: string) {
    let dts = param
      .replace(multilineCommentsRE, "")
      .replace(singlelineCommentsRE, "");

    const code = dts.match(dtsReg)?.[0];
    if (!code) return;

    return Object.fromEntries(
      [
        ...code.matchAll(
          /["']?(?<temp2>const\s*[^\s"']+)["']?\s*:\s*(?<temp1>.+?)[\n\r,;]/g
        )
      ].map(i => [i[1], i[2]])
    );
  }

  async function generateDTS(file: string) {
    await importsPromise;
    const dir = dirname(file);
    const originalContent = existsSync(file)
      ? await fs.readFile(file, "utf8")
      : "";
    const originalDTS = parseDTS(originalContent);
    let currentContent = await unimport.generateTypeDeclarations({
      resolvePath: i => {
        if (i.from.startsWith(".") || isAbsolute(i.from)) {
          const related = slash(
            relative(dir, i.from).replace(/\.ts(?<temp1>x)?$/, "")
          );
          return related.startsWith(".") ? related : `./${related}`;
        }
        return i.from;
      }
    });
    const currentDTS = parseDTS(currentContent)!;
    if (options.vueTemplate) {
      currentContent = currentContent.replace(
        componentCustomPropertiesReg,
        $1 => `interface GlobalComponents {}\n  ${$1}`
      );
    }
    if (originalDTS) {
      for (const key of Object.keys(currentDTS)) {
        originalDTS[key] = currentDTS[key];
      }
      const dtsList = Object.keys(originalDTS)
        .sort()
        .map(k => `  ${k}: ${originalDTS[k]}`);
      return currentContent.replace(
        dtsReg,
        () => `declare global {\n${dtsList.join("\n")}\n}`
      );
    }

    return currentContent;
  }

  async function generateESLintrc() {
    const configStr = existsSync(eslint.eslintrcFilepath!)
      ? await fs.readFile(eslint.eslintrcFilepath!, "utf8")
      : "";
    const config = JSON.parse(configStr || '{ "globals": {} }');

    return generateESLintrcConfigs(
      await unimport.getImports(),
      eslint,
      config.globals
    );
  }

  async function generateESLintFlat() {
    return generateESLintFlatConfigs(await unimport.getImports(), eslint);
  }

  async function generateBiomeLint() {
    return generateBiomeLintConfigs(await unimport.getImports());
  }

  const writeConfigFilesThrottled = throttle(500, writeConfigFiles, {
    noLeading: false
  });

  async function writeFile(filePath: string, content = "") {
    await fs.mkdir(dirname(filePath), { recursive: true });
    return fs.writeFile(filePath, content, "utf8");
  }

  let lastDTS: string | undefined;
  let lastESLint: string | undefined;
  let lastBiomeLint: string | undefined;
  let lastUnimportItems: string | undefined;

  async function writeConfigFiles() {
    const promises: any[] = [];
    if (dts) {
      promises.push(
        generateDTS(dts).then(content => {
          if (content !== lastDTS) {
            lastDTS = content;
            return writeFile(dts, content);
          }
        })
      );
    }

    if (eslint.eslintrcFilepath) {
      if (/\.[cm]?[jt]sx?$/.test(eslint.eslintrcFilepath)) {
        // eslint-disable-next-line no-console
        console.warn(
          `[storm-stack] ESLintrc config file should be a JSON file, not a JS/TS file. Skip creating ${eslint.eslintrcFilepath}`
        );
      } else {
        promises.push(
          generateESLintrc().then(async content => {
            if (content.trim() !== lastESLint?.trim()) {
              lastESLint = content;
              return writeFile(eslint.eslintrcFilepath!, content);
            }
          })
        );
      }
    }

    if (eslint.eslintFlatFilepath) {
      if (/\.c?json$/.test(eslint.eslintFlatFilepath)) {
        // eslint-disable-next-line no-console
        console.warn(
          `[storm-stack] ESLint flat config file should be a TS/JS file, not a JSON file. Skip creating ${eslint.eslintFlatFilepath}`
        );
      } else {
        promises.push(
          generateESLintFlat().then(async content => {
            if (content.trim() !== lastESLint?.trim()) {
              lastESLint = content;
              return writeFile(eslint.eslintFlatFilepath!, content);
            }
          })
        );
      }
    }

    if (biomelintrc.enabled) {
      promises.push(
        generateBiomeLint().then(content => {
          if (content !== lastBiomeLint) {
            lastBiomeLint = content;
            return writeFile(biomelintrc.filepath!, content);
          }
        })
      );
    }

    if (dumpUnimportItems) {
      promises.push(
        unimport.getImports().then(items => {
          if (!dumpUnimportItems) return;
          const content = JSON.stringify(items, null, 2);
          if (content !== lastUnimportItems) {
            lastUnimportItems = content;
            return writeFile(dumpUnimportItems, content);
          }
        })
      );
    }

    return Promise.all(promises);
  }

  async function scanDirs() {
    await unimport.modifyDynamicImports(async imports => {
      const exports_ =
        (await unimport.scanImportsFromDir()) as ImportExtended[];
      for (const i of exports_) i.__source = "dir";
      return modifyDefaultExportsAlias(
        [
          ...imports.filter((i: ImportExtended) => i.__source !== "dir"),
          ...exports_
        ],
        options
      );
    });

    writeConfigFilesThrottled();
  }

  async function transform(code: string, id: string) {
    await importsPromise;

    const s = new MagicString(code);

    await unimport.injectImports(s, id);

    if (!s.hasChanged()) return;

    writeConfigFilesThrottled();

    return {
      code: s.toString(),
      map: s.generateMap({ source: id, includeContent: true, hires: true })
    };
  }

  return {
    root,
    dirs,
    filter,
    scanDirs,
    writeConfigFiles,
    writeConfigFilesThrottled,
    transform,
    generateDTS,
    generateESLintrc,
    generateESLintFlat,
    unimport
  };
}

export async function flattenImports(
  map: Options["imports"]
): Promise<Import[]> {
  const promises = await Promise.all(
    toArray(map).map(async param => {
      let definition = param as any;
      if (typeof definition === "string") {
        if (!presets[definition]) {
          throw new Error(`[storm-stack] preset ${definition} not found`);
        }
        const preset = presets[definition];
        definition = typeof preset === "function" ? preset() : preset;
      }

      if ("from" in definition && "imports" in definition) {
        return resolvePreset(definition as InlinePreset);
      }
      const resolved: Import[] = [];
      for (const mod of Object.keys(definition)) {
        for (const id of definition[mod]) {
          const meta = {
            from: mod
          } as Import;
          if (Array.isArray(id)) {
            meta.name = id[0];
            meta.as = id[1];
          } else {
            meta.name = id;
            meta.as = id;
          }
          resolved.push(meta);
        }
      }
      return resolved;
    })
  );

  return promises.flat();
}

function modifyDefaultExportsAlias(
  imports: ImportExtended[],
  options: Options
): Import[] {
  if (options.defaultExportByFilename) {
    for (const i of imports) {
      if (i.name === "default") {
        i.as = i.from.split("/").pop()?.split(".")?.shift() ?? i.as;
      }
    }
  }

  return imports as Import[];
}
