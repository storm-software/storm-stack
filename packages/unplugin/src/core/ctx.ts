/*-------------------------------------------------------------------

                  âš¡ Storm Software - Storm Stack

 This code was released as part of the Storm Stack project. Storm Stack
 is maintained by Storm Software under the Apache-2.0 License, and is
 free for commercial and private use. For more information, please visit
 our licensing page.

 Website:         https://stormsoftware.com
 Repository:      https://github.com/storm-software/storm-stack
 Documentation:   https://stormsoftware.com/projects/storm-stack/docs
 Contact:         https://stormsoftware.com/contact
 License:         https://stormsoftware.com/projects/storm-stack/license

 -------------------------------------------------------------------*/

import { slash, throttle, toArray } from "@antfu/utils";
import { createFilter } from "@rollup/pluginutils";
import { LogType } from "consola";
import { isPackageExists } from "local-pkg";
import MagicString from "magic-string";
import { existsSync, promises as fs } from "node:fs";
import { dirname, isAbsolute, relative, resolve } from "node:path";
import process from "node:process";
import type { Import, InlinePreset } from "unimport";
import { createUnimport, resolvePreset } from "unimport";
import type { ResolvedConfig } from "vite";
import { presets } from "../presets";
import type {
  ImportExtended,
  Options,
  ResolvedOptions,
  Resolver
} from "../types";
import { generateBiomeLintConfigs } from "./biome";
import { generateESLintFlatConfigs, generateESLintrcConfigs } from "./eslint";
import { resolversAddon } from "./resolvers";
import { generateCode } from "./typia";
import { writeConsoleLog } from "./utilities";

export function createContext(
  rawOptions: Options = {},
  config: Partial<ResolvedConfig> = {}
) {
  let root = slash(config.root || process.cwd());

  const preferDTS = isPackageExists("typescript");

  const options = {
    ...rawOptions,
    imports: [
      ...(rawOptions.imports
        ? Array.isArray(rawOptions.imports)
          ? rawOptions.imports
          : [rawOptions.imports]
        : []),
      "storm-stack"
    ] as ResolvedOptions["imports"],
    packagePresets: rawOptions.packagePresets ?? [],
    ignore: rawOptions.ignore ?? [],
    ignoreDts: rawOptions.ignoreDts ?? [],
    include: rawOptions.include || [],
    exclude: rawOptions.exclude || [],
    silent: rawOptions.silent ?? false,
    defaultExportByFilename: Boolean(rawOptions.defaultExportByFilename),
    dts:
      preferDTS === false
        ? false
        : preferDTS === true
          ? resolve(root, "storm-stack.d.ts")
          : resolve(root, preferDTS),
    dirsScanOptions: rawOptions.dirsScanOptions ?? {},
    dirs: rawOptions.dirs ?? [],
    vueDirectives: rawOptions.vueDirectives ?? {},
    vueTemplate: rawOptions.vueTemplate ?? false,
    eslint: {
      enabled: rawOptions.eslint?.enabled ?? false,
      eslintrcFilepath:
        rawOptions.eslint?.enabled === true ||
        rawOptions.eslint?.enabled === "eslintrc"
          ? rawOptions.eslint?.eslintrcFilepath ||
            "./.eslintrc-storm-stack.json"
          : undefined,
      eslintFlatFilepath:
        rawOptions.eslint?.enabled === true ||
        rawOptions.eslint?.enabled === "eslint-flat"
          ? rawOptions.eslint?.eslintFlatFilepath ||
            "./eslint-storm-stack.config.js"
          : undefined,
      globalsPropValue: rawOptions.eslint?.globalsPropValue ?? true
    },
    biome: {
      enabled: rawOptions.biome?.enabled ?? false,
      filepath: rawOptions.biome?.filepath || "./biome.json"
    },
    parser: rawOptions.parser,
    // eslint-disable-next-line unicorn/no-magic-array-flat-depth
    resolvers: rawOptions.resolvers ? [rawOptions.resolvers].flat(2) : [],
    injectAtEnd: rawOptions.injectAtEnd !== false,
    dumpUnimportItems:
      rawOptions.dumpUnimportItems === true
        ? "./.unimport-items.json"
        : (rawOptions.dumpUnimportItems ?? false),
    viteOptimizeDeps: rawOptions.viteOptimizeDeps ?? true
  } as ResolvedOptions;

  const {
    dts,
    injectAtEnd,
    resolvers,
    parser,
    eslint,
    biome,
    dirsScanOptions,
    dirs,
    vueDirectives,
    vueTemplate,
    dumpUnimportItems
  } = options;

  const unimport = createUnimport({
    imports: [],
    presets:
      options.packagePresets?.map(p =>
        typeof p === "string" ? { package: p } : p
      ) ?? [],
    dirsScanOptions: {
      ...dirsScanOptions,
      cwd: root
    },
    dirs,
    injectAtEnd,
    parser,
    addons: {
      addons: [
        resolversAddon(resolvers as Resolver[]),
        {
          name: "unplugin-storm-stack:dts",
          declaration(dts) {
            return `${`
/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-storm-stack
// biome-ignore lint: disable

${dts}

`.trim()}\n`;
          }
        }
      ],
      vueDirectives,
      vueTemplate
    }
  });

  const writeLog = (type: LogType, ...args: string[]) => {
    if (!options.silent) {
      writeConsoleLog(type, ...args);
    }
  };

  const importsPromise = flattenImports(options.imports).then(imports => {
    if (imports.length === 0 && resolvers.length === 0 && !dirs?.length) {
      writeLog(
        "warn",
        "plugin installed but no imports has defined, see https://github.com/antfu/unplugin-auto-import#configurations for configurations"
      );
    }

    const compare = (
      left: string | undefined,
      right: NonNullable<Options["ignore"] | Options["ignoreDts"]>[number]
    ) => {
      return right instanceof RegExp ? right.test(left!) : right === left;
    };

    if (options.ignore) {
      for (const name of options.ignore) {
        const i = imports.find(i => compare(i.as, name));
        if (i) i.disabled = true;
      }
    }

    if (options.ignoreDts) {
      for (const name of options.ignoreDts) {
        const i = imports.find(i => compare(i.as, name));
        if (i) i.dtsDisabled = true;
      }
    }

    return unimport.getInternalContext().replaceImports(imports);
  });

  const filter: (id: string | unknown) => boolean = createFilter(
    options.include || [/\.[cm]?tsx?$/],
    options.exclude || [/[/\\]node_modules[/\\]/, /[/\\]\.git[/\\]/]
  );

  const multilineCommentsRE = /\/\*.*?\*\//gs;
  const singlelineCommentsRE = /\/\/.*$/gm;
  const dtsReg = /declare\s+global\s*{(?<temp1>.*?)[\n\r]}/s;
  const componentCustomPropertiesReg =
    /interface\s+ComponentCustomProperties\s*{(?<temp1>.*?)[\n\r]}/gs;
  function parseDTS(param: string) {
    let dts = param
      .replace(multilineCommentsRE, "")
      .replace(singlelineCommentsRE, "");

    const code = dts.match(dtsReg)?.[0];
    if (!code) return;

    return Object.fromEntries(
      [
        ...code.matchAll(
          /["']?(?<temp2>const\s*[^\s"']+)["']?\s*:\s*(?<temp1>.+?)[\n\r,;]/g
        )
      ].map(i => [i[1], i[2]])
    );
  }

  async function generateDTS(file: string) {
    await importsPromise;
    const dir = dirname(file);
    const originalContent = existsSync(file)
      ? await fs.readFile(file, "utf8")
      : "";
    const originalDTS = parseDTS(originalContent);
    let currentContent = await unimport.generateTypeDeclarations({
      resolvePath: i => {
        if (i.from.startsWith(".") || isAbsolute(i.from)) {
          const related = slash(
            relative(dir, i.from).replace(/\.ts(?<temp1>x)?$/, "")
          );
          return related.startsWith(".") ? related : `./${related}`;
        }
        return i.from;
      }
    });
    const currentDTS = parseDTS(currentContent)!;
    if (options.vueTemplate) {
      currentContent = currentContent.replace(
        componentCustomPropertiesReg,
        $1 => `interface GlobalComponents {}\n  ${$1}`
      );
    }
    if (originalDTS) {
      for (const key of Object.keys(currentDTS)) {
        originalDTS[key] = currentDTS[key];
      }
      const dtsList = Object.keys(originalDTS)
        .sort()
        .map(k => `  ${k}: ${originalDTS[k]}`);
      return currentContent.replace(
        dtsReg,
        () => `declare global {\n${dtsList.join("\n")}\n}`
      );
    }

    return currentContent;
  }

  async function generateESLintrc() {
    const configStr = existsSync(eslint.eslintrcFilepath!)
      ? await fs.readFile(eslint.eslintrcFilepath!, "utf8")
      : "";
    const config = JSON.parse(configStr || '{ "globals": {} }');

    return generateESLintrcConfigs(
      await unimport.getImports(),
      eslint,
      config.globals
    );
  }

  async function generateESLintFlat() {
    return generateESLintFlatConfigs(await unimport.getImports(), eslint);
  }

  async function generateBiomeLint() {
    return generateBiomeLintConfigs(await unimport.getImports());
  }

  const writeConfigFilesThrottled = throttle(500, writeConfigFiles, {
    noLeading: false
  });

  async function writeFile(filePath: string, content = "") {
    await fs.mkdir(dirname(filePath), { recursive: true });
    return fs.writeFile(filePath, content, "utf8");
  }

  let lastDTS: string | undefined;
  let lastESLint: string | undefined;
  let lastBiomeLint: string | undefined;
  let lastUnimportItems: string | undefined;

  async function writeConfigFiles() {
    const promises: any[] = [];
    if (dts) {
      promises.push(
        generateDTS(dts).then(async content => {
          if (content !== lastDTS) {
            lastDTS = content;
            await writeFile(dts, content);
          }
        })
      );
    }

    if (eslint.eslintrcFilepath) {
      if (/\.[cm]?[jt]sx?$/.test(eslint.eslintrcFilepath)) {
        writeLog(
          "warn",
          `ESLintrc config file should be a JSON file, not a JS/TS file. Skip creating ${eslint.eslintrcFilepath}`
        );
      } else {
        promises.push(
          generateESLintrc().then(async content => {
            if (content.trim() !== lastESLint?.trim()) {
              lastESLint = content;
              await writeFile(eslint.eslintrcFilepath!, content);
            }
          })
        );
      }
    }

    if (eslint.eslintFlatFilepath) {
      if (/\.c?json$/.test(eslint.eslintFlatFilepath)) {
        writeLog(
          "warn",
          `ESLint flat config file should be a TS/JS file, not a JSON file. Skip creating ${eslint.eslintFlatFilepath}`
        );
      } else {
        promises.push(
          generateESLintFlat().then(async content => {
            if (content.trim() !== lastESLint?.trim()) {
              lastESLint = content;
              await writeFile(eslint.eslintFlatFilepath!, content);
            }
          })
        );
      }
    }

    if (biome?.enabled) {
      promises.push(
        generateBiomeLint().then(async content => {
          if (content !== lastBiomeLint) {
            lastBiomeLint = content;
            await writeFile(biome.filepath!, content);
          }
        })
      );
    }

    if (dumpUnimportItems) {
      promises.push(
        unimport.getImports().then(async items => {
          if (!dumpUnimportItems) return;
          const content = JSON.stringify(items, null, 2);
          if (content !== lastUnimportItems) {
            lastUnimportItems = content;
            await writeFile(dumpUnimportItems, content);
          }
        })
      );
    }

    return Promise.all(promises);
  }

  async function scanDirs() {
    await unimport.modifyDynamicImports(async imports => {
      const exports_ =
        (await unimport.scanImportsFromDir()) as ImportExtended[];
      for (const i of exports_) i.__source = "dir";
      return modifyDefaultExportsAlias(
        [
          ...imports.filter((i: ImportExtended) => i.__source !== "dir"),
          ...exports_
        ],
        options
      );
    });

    writeConfigFilesThrottled();
  }

  async function transform(src: string, id: string) {
    await importsPromise;

    const source = new MagicString(src);

    await unimport.injectImports(source, id);
    if (source.hasChanged()) {
      writeConfigFilesThrottled();
    }

    /** skip if source does not include typia */
    if (!source.toString().includes("typia")) {
      if (!source.hasChanged()) {
        return;
      }

      return {
        code: source.toString(),
        map: source.generateMap({
          source: id,
          includeContent: true,
          hires: true
        })
      };
    }

    return generateCode({
      id,
      source,
      context: this,
      config,
      options,
      writeLog
    });
  }

  return {
    root,
    options,
    config,
    dirs,
    writeLog,
    filter,
    scanDirs,
    writeConfigFiles,
    writeConfigFilesThrottled,
    transform,
    generateDTS,
    generateESLintrc,
    generateESLintFlat,
    unimport
  };
}

export type PluginContext = ReturnType<typeof createContext>;

export async function flattenImports(
  map: Options["imports"]
): Promise<Import[]> {
  const promises = await Promise.all(
    toArray(map).map(async param => {
      let definition = param as any;
      if (typeof definition === "string") {
        if (!presets[definition]) {
          throw new Error(`[storm-stack] preset ${definition} not found`);
        }
        const preset = presets[definition];
        definition = typeof preset === "function" ? preset() : preset;
      }

      if ("from" in definition && "imports" in definition) {
        return resolvePreset(definition as InlinePreset);
      }
      const resolved: Import[] = [];
      for (const mod of Object.keys(definition)) {
        for (const id of definition[mod]) {
          const meta = {
            from: mod
          } as Import;
          if (Array.isArray(id)) {
            meta.name = id[0];
            meta.as = id[1];
          } else {
            meta.name = id;
            meta.as = id;
          }
          resolved.push(meta);
        }
      }
      return resolved;
    })
  );

  return promises.flat();
}

function modifyDefaultExportsAlias(
  imports: ImportExtended[],
  options: Options
): Import[] {
  if (options.defaultExportByFilename) {
    for (const i of imports) {
      if (i.name === "default") {
        i.as = i.from.split("/").pop()?.split(".")?.shift() ?? i.as;
      }
    }
  }

  return imports as Import[];
}
